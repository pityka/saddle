[{"id":0,"href":"/saddle/docs/getting_started/","title":"Getting started","section":"Docs","content":"Add any of these lines to your build.sbt:\n// The core library libraryDependencies += \u0026#34;io.github.pityka\u0026#34; % \u0026#34;saddle-core\u0026#34; % \u0026#34;0.0.0+1-529bd730-SNAPSHOT\u0026#34; // Inlined binary operation instances for Mat and Vec libraryDependencies += \u0026#34;io.github.pityka\u0026#34; % \u0026#34;saddle-ops-inlined\u0026#34; % \u0026#34;0.0.0+1-529bd730-SNAPSHOT\u0026#34; // Linear algebra interface to BLAS libraryDependencies += \u0026#34;io.github.pityka\u0026#34; % \u0026#34;saddle-linalg\u0026#34; % \u0026#34;0.0.0+1-529bd730-SNAPSHOT\u0026#34; // Binary representation of data frames and matrices libraryDependencies += \u0026#34;io.github.pityka\u0026#34; % \u0026#34;saddle-binary\u0026#34; % \u0026#34;0.0.0+1-529bd730-SNAPSHOT\u0026#34; // Circe Encoder and Decoder instances libraryDependencies += \u0026#34;io.github.pityka\u0026#34; % \u0026#34;saddle-circe\u0026#34; % \u0026#34;0.0.0+1-529bd730-SNAPSHOT\u0026#34; // Interface to joda time (not maintained) libraryDependencies += \u0026#34;io.github.pityka\u0026#34; % \u0026#34;saddle-time\u0026#34; % \u0026#34;0.0.0+1-529bd730-SNAPSHOT\u0026#34; // Interface to EJML (not maintained) libraryDependencies += \u0026#34;io.github.pityka\u0026#34; % \u0026#34;saddle-stats\u0026#34; % \u0026#34;0.0.0+1-529bd730-SNAPSHOT\u0026#34; Dependencies #  The actively maintained artifacts have minimal dependencies:\n saddle-core depends on cats-kernel saddle-linalg depends on netlib-java saddle-binary depends on ujson saddle-circe depends on circe  Example: SVD on the Iris dataset #  import scala.io.Source import org.saddle._ val irisURL = \u0026#34;https://gist.githubusercontent.com/pityka/d05bb892541d71c2a06a0efb6933b323/raw/639388c2cbc2120a14dcf466e85730eb8be498bb/iris.csv\u0026#34; // irisURL: String = \u0026#34;https://gist.githubusercontent.com/pityka/d05bb892541d71c2a06a0efb6933b323/raw/639388c2cbc2120a14dcf466e85730eb8be498bb/iris.csv\u0026#34; val iris = csv.CsvParser.parseSourceWithHeader[Double]( source = Source.fromURL(irisURL), cols = List(0,1,2,3), recordSeparator = \u0026#34;\\n\u0026#34;).toOption.get // iris: Frame[Int, String, Double] = [150 x 4] // sepal_length sepal_width petal_length petal_width // ------------ ----------- ------------ ----------- // 0 -\u0026gt; 5.1000 3.5000 1.4000 0.2000 // 1 -\u0026gt; 4.9000 3.0000 1.4000 0.2000 // 2 -\u0026gt; 4.7000 3.2000 1.3000 0.2000 // 3 -\u0026gt; 4.6000 3.1000 1.5000 0.2000 // 4 -\u0026gt; 5.0000 3.6000 1.4000 0.2000 // ... // 145 -\u0026gt; 6.7000 3.0000 5.2000 2.3000 // 146 -\u0026gt; 6.3000 2.5000 5.0000 1.9000 // 147 -\u0026gt; 6.5000 3.0000 5.2000 2.0000 // 148 -\u0026gt; 6.2000 3.4000 5.4000 2.3000 // 149 -\u0026gt; 5.9000 3.0000 5.1000 1.8000 //  import org.saddle.linalg._ val centered = iris.mapVec(_.demeaned) // centered: Frame[Int, String, Double] = [150 x 4] // sepal_length sepal_width petal_length petal_width // ------------ ----------- ------------ ----------- // 0 -\u0026gt; -0.7433 0.4460 -2.3587 -0.9987 // 1 -\u0026gt; -0.9433 -0.0540 -2.3587 -0.9987 // 2 -\u0026gt; -1.1433 0.1460 -2.4587 -0.9987 // 3 -\u0026gt; -1.2433 0.0460 -2.2587 -0.9987 // 4 -\u0026gt; -0.8433 0.5460 -2.3587 -0.9987 // ... // 145 -\u0026gt; 0.8567 -0.0540 1.4413 1.1013 // 146 -\u0026gt; 0.4567 -0.5540 1.2413 0.7013 // 147 -\u0026gt; 0.6567 -0.0540 1.4413 0.8013 // 148 -\u0026gt; 0.3567 0.3460 1.6413 1.1013 // 149 -\u0026gt; 0.0567 -0.0540 1.3413 0.6013 // val SVDResult(u, s, vt) = centered.toMat.svd(2) // u: Mat[Double] = [150 x 2] // 0.1070 0.0544 // 0.1082 -0.0282 // 0.1152 -0.0229 // 0.1095 -0.0518 // ... // -0.0608 -0.0624 // -0.0703 0.0131 // -0.0758 0.0193 // -0.0554 -0.0471 // // s: Vec[Double] = [2 x 1] // 25.0899 // 6.0079 // // vt: Mat[Double] = [2 x 4] // -0.3616 0.0823 -0.8566 -0.3588 // 0.6565 0.7297 -0.1758 -0.0747 // val pca = u.mDiagFromRight(s).toFrame // pca: Frame[Int, Int, Double] = [150 x 2] // 0 1 // ------- ------- // 0 -\u0026gt; 2.6842 0.3266 // 1 -\u0026gt; 2.7154 -0.1696 // 2 -\u0026gt; 2.8898 -0.1373 // 3 -\u0026gt; 2.7464 -0.3111 // 4 -\u0026gt; 2.7286 0.3339 // ... // 145 -\u0026gt; -1.9440 0.1874 // 146 -\u0026gt; -1.5257 -0.3750 // 147 -\u0026gt; -1.7640 0.0785 // 148 -\u0026gt; -1.9016 0.1159 // 149 -\u0026gt; -1.3897 -0.2829 // "},{"id":1,"href":"/saddle/docs/usage/","title":"Usage","section":"Docs","content":"Imports #  You most likely need the following two imports:\nimport org.saddle._ import org.saddle.order._ Note that org.saddle.order._ imports cats.kernel.Order[_] typeclass instances into the scope. If you import cats instances an other way then you should not import org.saddle.order._.\nThe Order[Double] and Order[Float] instances in org.saddle.order define a total ordering and order NaN above all other values, consistent with java.lang.Double.compare.\n1D vector: Vec[T] #  Factories:\nimport org.saddle._ Vec(1, 2, 3) // res0: Vec[Int] = [3 x 1] // 1 // 2 // 3 // Vec(1 to 3 : _*) // res1: Vec[Int] = [3 x 1] // 1 // 2 // 3 // Vec(Array(1,2,3)) // res2: Vec[Int] = [3 x 1] // 1 // 2 // 3 // Vec.empty[Double] // res3: Vec[Double] = Empty Vec  vec.ones(2) // res4: Vec[Double] = [2 x 1] // 1.0000 // 1.0000 // vec.zeros(3) // res5: Vec[Double] = [3 x 1] // 0.0000 // 0.0000 // 0.0000 // vec.rand(20) // res6: Vec[Double] = [20 x 1] // 0.8667 // 0.1198 // 0.7893 // 0.9700 // 0.9894 // ... // 0.6674 // 0.0862 // 0.2420 // 0.9997 // 0.1544 // Operations:\nimport org.saddle.ops.BinOps._ Vec(1,2,3) + Vec(4,5,6) // res7: Vec[Int] = [3 x 1] // 5 // 7 // 9 // Vec(1,2,3) * Vec(4,5,6) // res8: Vec[Int] = [3 x 1] // 4 // 10 // 18 // Vec(1,2,3) ** Vec(4,5,6) // res9: Vec[Int] = [3 x 1] // 1 // 32 // 729 // Note above, that you have to import that BinOp instances.\nAn alternative set of instances are also available which inline the innermost in Mat and Vec operations:\n// The macros package contains instances where the innermost loop is inlined. import org.saddle._ import org.saddle.macros.BinOps._ Vec(1,2,3) + Vec(4,5,6) // res11: Vec[Int] = [3 x 1] // 5 // 7 // 9 // Vec(1,2,3) * Vec(4,5,6) // res12: Vec[Int] = [3 x 1] // 4 // 10 // 18 // Vec(1,2,3) ** Vec(4,5,6) // res13: Vec[Int] = [3 x 1] // 1 // 32 // 729 // Slicing:\nimport org.saddle._ import org.saddle.ops.BinOps._ Vec(1,2,3).at(2) // Boxes and keeps NA // res15: scalar.Scalar[Int] = Value(el = 3) // Boxes and keeps NA Vec(1,2,3).raw(2) // res16: Int = 3 Vec(1,2,3).apply(2) // same as raw // res17: Int = 3 // same as raw Vec(1,2,3).take(0,2) // res18: Vec[Int] = [2 x 1] // 1 // 3 // Vec(1,2,3).take(1 -\u0026gt; *) // res19: Vec[Int] = [2 x 1] // 2 // 3 // Vec(1,2,3).take(* -\u0026gt; 1) // res20: Vec[Int] = [2 x 1] // 1 // 2 // 1D vector with index: Series[K,V] #  A Series combines a Vec with an Index that provides an ordered key-value mapping. We’ll talk more about the details of Index later.\nThe key type of a must have a natural ordering (ie, an Ordering of that type within the implicit scope). However, the Series maintains the order in which its data was supplied unless ordered othewise.\nLet’s look at a few constructions:\nimport org.saddle.order._ // we already know we can convert a Vec Series(Vec(32, 12, 9)) // res21: Series[Int, Int] = [3 x 1] // 0 -\u0026gt; 32 // 1 -\u0026gt; 12 // 2 -\u0026gt; 9 //  // we can pass a pair of tuples Series(\u0026#34;a\u0026#34; -\u0026gt; 1, \u0026#34;b\u0026#34; -\u0026gt; 2, \u0026#34;c\u0026#34; -\u0026gt; 3) // res22: Series[String, Int] = [3 x 1] // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; 3 //  // any series of tuples will work, eg: Series(List(\u0026#34;a\u0026#34; -\u0026gt; 1, \u0026#34;b\u0026#34; -\u0026gt; 2, \u0026#34;c\u0026#34; -\u0026gt; 3) : _*) // res23: Series[String, Int] = [3 x 1] // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; 3 //  // can pass data and index separately: Series(Vec(1,2,3), Index(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)) // res24: Series[String, Int] = [3 x 1] // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; 3 //  // you can create an empty Series like so: Series.empty[String, Int] // res25: Series[String, Int] = Empty Series  // supplied order is maintained: Series(Vec(1,2,3), Index(\u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;)) // res26: Series[String, Int] = [3 x 1] // c -\u0026gt; 1 // b -\u0026gt; 2 // a -\u0026gt; 3 //  // unlike map, multiple keys are entirely fine: Series(Vec(1,2,3,4), Index(\u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)) // res27: Series[String, Int] = [4 x 1] // c -\u0026gt; 1 // b -\u0026gt; 2 // a -\u0026gt; 3 // b -\u0026gt; 4 // With construction out of the way, let’s look at a few ways we can get data out of a Series.\nval q = Series(Vec(1,3,2,4), Index(\u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)) // q: Series[String, Int] = [4 x 1] // c -\u0026gt; 1 // b -\u0026gt; 3 // a -\u0026gt; 2 // b -\u0026gt; 4 //  // get the values or index  q.values // res28: Vec[Int] = [4 x 1] // 1 // 3 // 2 // 4 //  q.index // res29: Index[String] = [Index 4 x 1] // c // b // a // b //  // extract value by numerical offset  q.at(2) // res30: scalar.Scalar[Int] = Value(el = 2)  q.at(2,3,1) // res31: Series[String, Int] = [3 x 1] // a -\u0026gt; 2 // b -\u0026gt; 4 // b -\u0026gt; 3 //  // or extract key  q.keyAt(2) // res32: scalar.Scalar[String] = Value(el = \u0026#34;a\u0026#34;)  q.keyAt(2,3,1) // res33: Index[String] = [Index 3 x 1] // a // b // b //  // sort by index ordering  q.sortedIx // res34: Series[String, Int] = [4 x 1] // a -\u0026gt; 2 // b -\u0026gt; 3 // b -\u0026gt; 4 // c -\u0026gt; 1 //  // sort by value ordering  q.sorted // res35: Series[String, Int] = [4 x 1] // c -\u0026gt; 1 // a -\u0026gt; 2 // b -\u0026gt; 3 // b -\u0026gt; 4 //  // extract elements matching the index  q(\u0026#34;b\u0026#34;) // res36: Series[String, Int] = [2 x 1] // b -\u0026gt; 3 // b -\u0026gt; 4 //  q(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;) // res37: Series[String, Int] = [3 x 1] // a -\u0026gt; 2 // b -\u0026gt; 3 // b -\u0026gt; 4 //  // notice ordering subtleties:  q(\u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;) // res38: Series[String, Int] = [3 x 1] // b -\u0026gt; 3 // b -\u0026gt; 4 // a -\u0026gt; 2 //  // get first or last values  q.first // res39: scalar.Scalar[Int] = Value(el = 1)  q.last // res40: scalar.Scalar[Int] = Value(el = 4)  // or key  q.firstKey // res41: scalar.Scalar[String] = Value(el = \u0026#34;c\u0026#34;)  q.lastKey // res42: scalar.Scalar[String] = Value(el = \u0026#34;b\u0026#34;)  // \u0026#34;reindex\u0026#34; to a new index:  q.reindex(Index(\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;)) // res43: Series[String, Int] = [3 x 1] // a -\u0026gt; 2 // c -\u0026gt; 1 // d -\u0026gt; NA //  // or just by a sequence of keys:  q.reindex(\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;) // res44: Series[String, Int] = [3 x 1] // a -\u0026gt; 2 // c -\u0026gt; 1 // d -\u0026gt; NA //  // notice that \u0026#39;slicing\u0026#39; ignores unknown keys:  q(\u0026#34;a\u0026#34;, \u0026#34;d\u0026#34;) // res45: Series[String, Int] = [1 x 1] // a -\u0026gt; 2 // // we cannot reindex with \u0026#34;b\u0026#34;, because it isn\u0026#39;t unique. // (the problem is, which \u0026#34;b\u0026#34; would we choose?)  q.reindex(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;) // java.lang.IllegalArgumentException: requirement failed: Could not reindex unambiguously // at scala.Predef$.require(Predef.scala:337) // at org.saddle.Index.getIndexer(Index.scala:426) // at org.saddle.Index.getIndexer$(Index.scala:422) // at org.saddle.index.IndexAny.getIndexer(IndexAny.scala:27) // at org.saddle.Series$mcI$sp.reindex$mcI$sp(Series.scala:247) // at org.saddle.Series$mcI$sp.reindex$mcI$sp(Series.scala:256) // at repl.MdocSession$App14$$anonfun$1.apply(usage.md:190) // at repl.MdocSession$App14$$anonfun$1.apply(usage.md:190) // we can \u0026#34;reset\u0026#34; the index to integer labels  q.resetIndex // res46: Series[Int, Int] = [4 x 1] // 0 -\u0026gt; 1 // 1 -\u0026gt; 3 // 2 -\u0026gt; 2 // 3 -\u0026gt; 4 //  // or to a new index altogether  q.setIndex(Index(\u0026#34;w\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;)) // res47: Series[String, Int] = [4 x 1] // w -\u0026gt; 1 // x -\u0026gt; 3 // y -\u0026gt; 2 // z -\u0026gt; 4 //  // to \u0026#39;slice\u0026#39;, we need a sorted index; slice is inclusive by default  val s = q.sortedIx // s: Series[String, Int] = [4 x 1] // a -\u0026gt; 2 // b -\u0026gt; 3 // b -\u0026gt; 4 // c -\u0026gt; 1 //  s.sliceBy(\u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;) // res48: Series[String, Int] = [3 x 1] // b -\u0026gt; 3 // b -\u0026gt; 4 // c -\u0026gt; 1 //  // syntactic sugar is provided:  s.sliceBy(\u0026#34;b\u0026#34; -\u0026gt; \u0026#34;c\u0026#34;) // res49: Series[String, Int] = [3 x 1] // b -\u0026gt; 3 // b -\u0026gt; 4 // c -\u0026gt; 1 //  s.sliceBy(* -\u0026gt; \u0026#34;b\u0026#34;) // res50: Series[String, Int] = [3 x 1] // a -\u0026gt; 2 // b -\u0026gt; 3 // b -\u0026gt; 4 //  // where slice is by offset, exclusive by default, and the // index doesn\u0026#39;t have to be sorted:  q.slice(0,2) // res51: Series[String, Int] = [2 x 1] // c -\u0026gt; 1 // b -\u0026gt; 3 //  // there are head/tail methods:  q.head(2) // res52: Series[String, Int] = [2 x 1] // c -\u0026gt; 1 // b -\u0026gt; 3 //  q.tail(2) // res53: Series[String, Int] = [2 x 1] // a -\u0026gt; 2 // b -\u0026gt; 4 // Aside from extracting values, there are many fun ways to compute with Series. Try the following:\nq.mapValues(_ + 1) // res54: Series[String, Int] = [4 x 1] // c -\u0026gt; 2 // b -\u0026gt; 4 // a -\u0026gt; 3 // b -\u0026gt; 5 // q.mapIndex(_ + \u0026#34;x\u0026#34;) // res55: Series[String, Int] = [4 x 1] // cx -\u0026gt; 1 // bx -\u0026gt; 3 // ax -\u0026gt; 2 // bx -\u0026gt; 4 // q.shift(1) // res56: Series[String, Int] = [4 x 1] // c -\u0026gt; NA // b -\u0026gt; 1 // a -\u0026gt; 3 // b -\u0026gt; 2 // q.filter(_ \u0026gt; 2) // res57: Series[String, Int] = [2 x 1] // b -\u0026gt; 3 // b -\u0026gt; 4 // q.filterIx(_ != \u0026#34;b\u0026#34;) // res58: Series[String, Int] = [2 x 1] // c -\u0026gt; 1 // a -\u0026gt; 2 // q.filterAt { case loc =\u0026gt; loc != 1 \u0026amp;\u0026amp; loc != 3 } // res59: Series[String, Int] = [2 x 1] // c -\u0026gt; 1 // a -\u0026gt; 2 // q.find(_ == 2) // res60: Vec[Int] = [1 x 1] // 2 // q.findKey { case x =\u0026gt; x == 2 || x == 3 } // res61: Index[String] = [Index 2 x 1] // b // a // q.findOneKey { case x =\u0026gt; x == 2 || x == 3 } // res62: scalar.Scalar[String] = Value(el = \u0026#34;b\u0026#34;) q.minKey // res63: scalar.Scalar[String] = Value(el = \u0026#34;c\u0026#34;) q.contains(\u0026#34;a\u0026#34;) // res64: Boolean = true q.scanLeft(0) { case (acc, v) =\u0026gt; acc + v } // res65: Series[String, Int] = [4 x 1] // c -\u0026gt; 1 // b -\u0026gt; 4 // a -\u0026gt; 6 // b -\u0026gt; 10 // q.reversed // res66: Series[String, Int] = [4 x 1] // b -\u0026gt; 4 // a -\u0026gt; 2 // b -\u0026gt; 3 // c -\u0026gt; 1 //  val ma = q.mask(q.values \u0026gt; 2) // ma: Series[String, Int] = [4 x 1] // c -\u0026gt; 1 // b -\u0026gt; NA // a -\u0026gt; 2 // b -\u0026gt; NA // ma.hasNA // res67: Boolean = true ma.dropNA // res68: Series[String, Int] = [2 x 1] // c -\u0026gt; 1 // a -\u0026gt; 2 //  q.rolling(2, _.minKey) // res69: Series[String, scalar.Scalar[String]] = [3 x 1] // b -\u0026gt; c // a -\u0026gt; a // b -\u0026gt; a // q.splitAt(2) // res70: (Series[String, Int], Series[String, Int]) = ( // [2 x 1] // c -\u0026gt; 1 // b -\u0026gt; 3 // , // [2 x 1] // a -\u0026gt; 2 // b -\u0026gt; 4 // // ) q.sortedIx.splitBy(\u0026#34;b\u0026#34;) // res71: (Series[String, Int], Series[String, Int]) = ( // [1 x 1] // a -\u0026gt; 2 // , // [3 x 1] // b -\u0026gt; 3 // b -\u0026gt; 4 // c -\u0026gt; 1 // // ) We can of course convert to a Vec or a Seq if we need to. The Series.toSeq method yields a sequence of key/value tuples.\nq.toVec // res72: Vec[Int] = [4 x 1] // 1 // 3 // 2 // 4 //  q.toSeq // res73: IndexedSeq[(String, Int)] = ArraySeq( // (\u0026#34;c\u0026#34;, 1), // (\u0026#34;b\u0026#34;, 3), // (\u0026#34;a\u0026#34;, 2), // (\u0026#34;b\u0026#34;, 4) // ) We can also group by key in order to transform or combine the groupings, which themselves are Series. For example:\nq.groupBy.combine(_.sum) // res74: Series[String, Int] = [3 x 1] // a -\u0026gt; 2 // b -\u0026gt; 7 // c -\u0026gt; 1 //  q.groupBy.transform(s =\u0026gt; s - s.mean) // res75: Series[String, Double] = [4 x 1] // c -\u0026gt; 0.0000 // b -\u0026gt; -0.5000 // a -\u0026gt; 0.0000 // b -\u0026gt; 0.5000 // You can also group by another index, or by a transformation of the current index, by passing an argument into groupBy. See the Saddle API for more info.\nThe expressive nature of working with Series becomes apparent when you need to align data:\nval a = Series(Vec(1,4,2,3), Index(\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;)) // a: Series[String, Int] = [4 x 1] // a -\u0026gt; 1 // b -\u0026gt; 4 // c -\u0026gt; 2 // d -\u0026gt; 3 // val b = Series(Vec(5,2,1,8,7), Index(\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;)) // b: Series[String, Int] = [5 x 1] // b -\u0026gt; 5 // c -\u0026gt; 2 // d -\u0026gt; 1 // e -\u0026gt; 8 // f -\u0026gt; 7 //  a + b // res76: Series[String, Int] = [6 x 1] // a -\u0026gt; NA // b -\u0026gt; 9 // c -\u0026gt; 4 // d -\u0026gt; 4 // e -\u0026gt; NA // f -\u0026gt; NA // You see that the indexes have been aligned prior to operation being performed. Because there is a missing observation in each label of a, e, and f, the summation is not done and instead an NA value is inserted into the result.\nGenerally, a full-outer join is performed. So, for instance:\nval c = Series(Vec(1,4,2), Index(\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;b\u0026#34;)) // c: Series[String, Int] = [3 x 1] // a -\u0026gt; 1 // b -\u0026gt; 4 // b -\u0026gt; 2 // val d = Series(Vec(5,2,1), Index(\u0026#34;b\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;d\u0026#34;)) // d: Series[String, Int] = [3 x 1] // b -\u0026gt; 5 // b -\u0026gt; 2 // d -\u0026gt; 1 //  c + d // res77: Series[String, Int] = [6 x 1] // a -\u0026gt; NA // b -\u0026gt; 9 // b -\u0026gt; 6 // b -\u0026gt; 7 // b -\u0026gt; 4 // d -\u0026gt; NA // Most basic math and boolean operations are supported between two Series, as well as between a Series and a scalar value.\nWe mentioned joins. Let’s look at a few join operations; the result is a Frame, which we will touch on a bit later. These are similar in nature to SQL joins.\na.join(b, how=index.LeftJoin) // res78: Frame[String, Int, Int] = [4 x 2] // 0 1 // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 4 5 // c -\u0026gt; 2 2 // d -\u0026gt; 3 1 //  a.join(b, how=index.RightJoin) // res79: Frame[String, Int, Int] = [5 x 2] // 0 1 // -- -- // b -\u0026gt; 4 5 // c -\u0026gt; 2 2 // d -\u0026gt; 3 1 // e -\u0026gt; NA 8 // f -\u0026gt; NA 7 //  a.join(b, how=index.InnerJoin) // res80: Frame[String, Int, Int] = [3 x 2] // 0 1 // -- -- // b -\u0026gt; 4 5 // c -\u0026gt; 2 2 // d -\u0026gt; 3 1 //  a.join(b, how=index.OuterJoin) // res81: Frame[String, Int, Int] = [6 x 2] // 0 1 // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 4 5 // c -\u0026gt; 2 2 // d -\u0026gt; 3 1 // e -\u0026gt; NA 8 // f -\u0026gt; NA 7 // Matrix: Mat[T] #  A Mat[T] represents a matrix of values. Internally it is stored as a single contiguous array in row-major order.\nThe row-major layout is compatible with EJML, a linear algebra library running on the JVM. If you want to use a BLAS, you can take a look in saddle-linalg.\nLet’s start off with construction:\nimport org.saddle._ Mat(2,2, Array(1,2,3,4)) // res82: Mat[Int] = [2 x 2] // 1 2 // 3 4 //  // all same:  Mat(Array(Array(1,3), Array(2,4))) // res83: Mat[Int] = [2 x 2] // 1 2 // 3 4 //  Mat(Vec(1,3), Vec(2,4)) // res84: Mat[Int] = [2 x 2] // 1 2 // 3 4 //  Mat(Array(Vec(1,3), Vec(2,4))) // res85: Mat[Int] = [2 x 2] // 1 2 // 3 4 //  // identity matrix:  mat.ident(2) // res86: Mat[Double] = [2 x 2] // 1.0000 0.0000 // 0.0000 1.0000 //  // empty matrix:  Mat.empty[Double] // res87: Mat[Double] = [0 x 0] //  // zeros:  Mat[Int](2, 2) // res88: Mat[Int] = [2 x 2] // 0 0 // 0 0 // Again, sometimes we want to create instances filled with random observations. As to Vec, we can do the following:\nmat.rand(2,2) // res89: Mat[Double] = [2 x 2] // 0.1663 0.0802 // 0.6610 0.0863 //  mat.randp(2,2) // random positive doubles // res90: Mat[Double] = [2 x 2] // 0.2913 0.1572 // 0.6703 0.5429 // // random positive doubles  mat.randn(2,2) // random normally distributed doubles // res91: Mat[Double] = [2 x 2] // 1.9658 2.1118 // -0.6569 1.1562 // // random normally distributed doubles  mat.randn2(2,2,3,12) // random normally distributed with mean=3, stdev=12 // res92: Mat[Double] = [2 x 2] // 0.2865 -14.4165 // 9.6269 -4.4744 // There are a few other factory methods available:\nmat.ones(2,2) // res93: Mat[Double] = [2 x 2] // 1.0000 1.0000 // 1.0000 1.0000 //  mat.zeros(2,2) // res94: Mat[Double] = [2 x 2] // 0.0000 0.0000 // 0.0000 0.0000 //  mat.diag(Vec(1,2)) // res95: Mat[Double] = [2 x 2] // 1.0000 0.0000 // 0.0000 2.0000 // Let’s look at some basic operations with Mat. As with Vec, you may perform calculations on two Mat instances, or on a Mat and a scalar value.\n// element-wise multiplication  Mat(2,2,Array(1,2,3,4)) * Mat(2,2,Array(4,1,2,3)) // res96: Mat[Int] = [2 x 2] // 4 2 // 6 12 // Matrix multiplication and matrix-vector multiplication needs saddle-linalg, which depends on netlib-java. These only work on Mat[Double] and Vec[Double].\nimport org.saddle.linalg._ // matrix multiplication  Mat(2,2,Array(1d,2d,3d,4d)) mm Mat(2,2,Array(4d,1d,2d,3d)) // res97: Mat[Double] = [2 x 2] // 8.0000 7.0000 // 20.0000 15.0000 //  // matrix-vector multiplication  Mat(2,2,Array(1d,2d,3d,4d)) mv Vec(2d,1d) // res98: Vec[Double] = [2 x 1] // 4.0000 // 10.0000 //  // as expected  Mat(2,2,Array(1,2,3,4)) * 2 // res99: Mat[Int] = [2 x 2] // 2 4 // 6 8 //  Mat(2,2,Array(1,2,3,4)) + 2 // res100: Mat[Int] = [2 x 2] // 3 4 // 5 6 //  Mat(2,2,Array(1,2,3,4)) \u0026lt;\u0026lt; 2 // res101: Mat[Int] = [2 x 2] // 4 8 // 12 16 // // etc...  // transpose  Mat(2,2,Array(1,2,3,4)).T // res102: Mat[Int] = [2 x 2] // 1 3 // 2 4 //  // properties of Mat val m = Mat(2,2,Array(1,2,3,4)) // m: Mat[Int] = [2 x 2] // 1 2 // 3 4 //  m.numRows // res103: Int = 2  m.numCols // res104: Int = 2  m.isSquare // res105: Boolean = true  m.isEmpty // res106: Boolean = false There are a few ways to extract values from a Mat.\nm.at(0,1) // res107: scalar.Scalar[Int] = Value(el = 2)  // be careful with this one!  m.raw(0,1) // res108: Int = 2  m.takeRows(0) // res109: Mat[Int] = [1 x 2] // 1 2 //  m.withoutRows(0) // res110: Mat[Int] = [1 x 2] // 3 4 //  m.takeCols(0) // res111: Mat[Int] = [2 x 1] // 1 // 3 //  m.col(0) // res112: Vec[Int] = [2 x 1] // 1 // 3 //  m.row(0) // res113: Vec[Int] = [2 x 1] // 1 // 2 //  m.rows // res114: IndexedSeq[Vec[Int]] = Vector( // [2 x 1] // 1 // 2 // , // [2 x 1] // 3 // 4 // // )  m.cols // res115: IndexedSeq[Vec[Int]] = Vector( // [2 x 1] // 1 // 3 // , // [2 x 1] // 2 // 4 // // ) Some other interesting methods on Mat:\nval m2 = Mat(2,2,Array(1,2,na.to[Int],4)) // m2: Mat[Int] = [2 x 2] // 1 2 // NA 4 //  m2.rowsWithNA // res116: Set[Int] = Set(1)  m2.dropRowsWithNA // res117: Mat[Int] = [1 x 2] // 1 2 //  m2.reshape(1,4) // res118: Mat[Int] = [1 x 4] // 1 2 NA 4 //  mat.rand(2,2).roundTo(2) // res119: Mat[Double] = [2 x 2] // 0.6400 0.5300 // 0.9400 0.1500 // Homogeneous table with row and column index (data frame) : Frame[RX,CX,T] #  A Frame combines a Mat with a row index and a column index which provides a way to index into the Mat.\nA Frame is represented internally as a sequence of column Vec instances all sharing the same row index.\nLet’s look at some ways to instantiated a Frame:\nval v = Vec(1, 2) // given the following // v: Vec[Int] = [2 x 1] // 1 // 2 // // given the following  val u = Vec(3, 4) // u: Vec[Int] = [2 x 1] // 3 // 4 //  val s2 = Series(\u0026#34;a\u0026#34; -\u0026gt; 1, \u0026#34;b\u0026#34; -\u0026gt; 2) // s2: Series[String, Int] = [2 x 1] // a -\u0026gt; 1 // b -\u0026gt; 2 //  val t = Series(\u0026#34;b\u0026#34; -\u0026gt; 3, \u0026#34;c\u0026#34; -\u0026gt; 4) // t: Series[String, Int] = [2 x 1] // b -\u0026gt; 3 // c -\u0026gt; 4 //  Frame(v, u) // two-column frame // res120: Frame[Int, Int, Int] = [2 x 2] // 0 1 // -- -- // 0 -\u0026gt; 1 3 // 1 -\u0026gt; 2 4 // // two-column frame  Frame(\u0026#34;x\u0026#34; -\u0026gt; v, \u0026#34;y\u0026#34; -\u0026gt; u) // with column index // res121: Frame[Int, String, Int] = [2 x 2] // x y // -- -- // 0 -\u0026gt; 1 3 // 1 -\u0026gt; 2 4 // // with column index  Frame(s2, t) // aligned along rows // res122: Frame[String, Int, Int] = [3 x 2] // 0 1 // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // aligned along rows  Frame(\u0026#34;x\u0026#34; -\u0026gt; s2, \u0026#34;y\u0026#34; -\u0026gt; t) // with column index // res123: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // with column index  Frame(Seq(s2, t), Index(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;)) // explicit column index // res124: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // explicit column index  Frame(Seq(v, u), Index(0, 1), Index(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;)) // row \u0026amp; col indexes specified explicitly // res125: Frame[Int, String, Int] = [2 x 2] // x y // -- -- // 0 -\u0026gt; 1 3 // 1 -\u0026gt; 2 4 // // row \u0026amp; col indexes specified explicitly  Frame(Seq(v, u), Index(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)) // col index specified // res126: Frame[Int, String, Int] = [2 x 2] // a b // -- -- // 0 -\u0026gt; 1 3 // 1 -\u0026gt; 2 4 // The factory methods which construct a Frame from columns as Series come in two flavors regarding their behavior upon non-unique indices in the series (duplicate row index values).\n The Frame.apply methods create a full cross product of the respective indices. This means that for a given value of the row index all respective items will be paired with all other, leading to a combinatorial explosion of the number of rows of the resulting Frame. The Frame.fromCols methods disambiguate the non-unique indices before joining. This avoids the combinatorial increase in the number of rows, at the cost of arbitrarily joining items with the same index value.  An example for the difference between Frame.apply and Frame.fromCols, note the rows with 0 index:\nFrame.fromCols( Series(0 -\u0026gt; 1, 2 -\u0026gt; 2, 1 -\u0026gt; 3, 0 -\u0026gt; 4), Series(1 -\u0026gt; 1, 2 -\u0026gt; 2, 0 -\u0026gt; 3, 0 -\u0026gt; 4), Series(0 -\u0026gt; 1, 1 -\u0026gt; 2, 2 -\u0026gt; 3, 0 -\u0026gt; 4) ) // res127: Frame[Int, Int, Int] = [4 x 3] // 0 1 2 // -- -- -- // 0 -\u0026gt; 1 3 1 // 2 -\u0026gt; 2 2 3 // 1 -\u0026gt; 3 1 2 // 0 -\u0026gt; 4 4 4 //  Frame.apply( Series(0 -\u0026gt; 1, 2 -\u0026gt; 2, 1 -\u0026gt; 3, 0 -\u0026gt; 4), Series(1 -\u0026gt; 1, 2 -\u0026gt; 2, 0 -\u0026gt; 3, 0 -\u0026gt; 4), Series(0 -\u0026gt; 1, 1 -\u0026gt; 2, 2 -\u0026gt; 3, 0 -\u0026gt; 4) ) // res128: Frame[Int, Int, Int] = [10 x 3] // 0 1 2 // -- -- -- // 0 -\u0026gt; 1 3 1 // 0 -\u0026gt; 1 3 4 // 0 -\u0026gt; 1 4 1 // 0 -\u0026gt; 1 4 4 // 0 -\u0026gt; 4 3 1 // 0 -\u0026gt; 4 3 4 // 0 -\u0026gt; 4 4 1 // 0 -\u0026gt; 4 4 4 // 2 -\u0026gt; 2 2 3 // 1 -\u0026gt; 3 1 2 // You’ll notice that if an index is not provided, a default int index is set where the index ranges between 0 and the length of the data.\nIf you want to set or reset the index, these methods are your friends:\nval f = Frame(\u0026#34;x\u0026#34; -\u0026gt; s2, \u0026#34;y\u0026#34; -\u0026gt; t) // f: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 //  f.setRowIndex(org.saddle.index.IndexIntRange(f.numRows)) // res129: Frame[Int, String, Int] = [3 x 2] // x y // -- -- // 0 -\u0026gt; 1 NA // 1 -\u0026gt; 2 3 // 2 -\u0026gt; NA 4 //  f.setColIndex(Index(\u0026#34;p\u0026#34;, \u0026#34;q\u0026#34;)) // res130: Frame[String, String, Int] = [3 x 2] // p q // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 //  f.resetRowIndex // res131: Frame[Int, String, Int] = [3 x 2] // x y // -- -- // 0 -\u0026gt; 1 NA // 1 -\u0026gt; 2 3 // 2 -\u0026gt; NA 4 //  f.resetColIndex // res132: Frame[String, Int, Int] = [3 x 2] // 0 1 // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // (Note: frame f will carry through the next examples.)\nYou also have the following index transformation tools at hand:\nf.mapRowIndex { case rx =\u0026gt; rx+1 } // res133: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a1 -\u0026gt; 1 NA // b1 -\u0026gt; 2 3 // c1 -\u0026gt; NA 4 // f.mapColIndex { case cx =\u0026gt; cx+2 } // res134: Frame[String, String, Int] = [3 x 2] // x2 y2 // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // Let’s next look at how to extract data from the Frame.\nf.rowAt(2) // extract row at offset 2, as Series // res135: Series[String, Int] = [2 x 1] // x -\u0026gt; NA // y -\u0026gt; 4 // // extract row at offset 2, as Series  f.rowAt(1,2) // extract frame of rows 1 \u0026amp; 2 // res136: Frame[String, String, Int] = [2 x 2] // x y // -- -- // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // extract frame of rows 1 \u0026amp; 2  f.rowAt(1-\u0026gt;2) // extract frame of rows 1 \u0026amp; 2 // res137: Frame[String, String, Int] = [2 x 2] // x y // -- -- // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // extract frame of rows 1 \u0026amp; 2  f.colAt(1) // extract col at offset 1, as Series // res138: Series[String, Int] = [3 x 1] // a -\u0026gt; NA // b -\u0026gt; 3 // c -\u0026gt; 4 // // extract col at offset 1, as Series  f.colAt(0,1) // extract frame of cols 1 \u0026amp; 2 // res139: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // extract frame of cols 1 \u0026amp; 2  f.colAt(0-\u0026gt;1) // extract frame of cols 1 \u0026amp; 2 // res140: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // rowAt and colAt are used under the hood for the at extractor:\nf.at(1,1) // Scalar value // res141: scalar.Scalar[Int] = Value(el = 3) // Scalar value  f.at(Array(1,2), 0) // extract rows 1,2 of column 0 // res142: Series[String, Int] = [2 x 1] // b -\u0026gt; 2 // c -\u0026gt; NA // If you want more control over slicing, you can use these methods:\nf.colSlice(0,1) // frame slice consisting of column 0 // res143: Frame[String, String, Int] = [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // // frame slice consisting of column 0  f.rowSlice(0,3,2) // row slice from 0 until 3, striding by 2 // res144: Frame[String, String, Int] = [2 x 2] // x y // -- -- // a -\u0026gt; 1 NA // c -\u0026gt; NA 4 // Of course, this is an bi-indexed data structure, so we can use its indexes to select out data using keys:\nf.row(\u0026#34;a\u0026#34;) // row series \u0026#39;a\u0026#39;, with all columns // res145: Frame[String, String, Int] = [1 x 2] // x y // -- -- // a -\u0026gt; 1 NA // // row series \u0026#39;a\u0026#39;, with all columns  f.col(\u0026#34;x\u0026#34;) // col series \u0026#39;x\u0026#39;, with all rows // res146: Frame[String, String, Int] = [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // // col series \u0026#39;x\u0026#39;, with all rows  f.row(\u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;) // select two rows // res147: Frame[String, String, Int] = [2 x 2] // x y // -- -- // a -\u0026gt; 1 NA // c -\u0026gt; NA 4 // // select two rows  f.row(\u0026#34;a\u0026#34;-\u0026gt;\u0026#34;b\u0026#34;) // slice two rows (index must be sorted) // res148: Frame[String, String, Int] = [2 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // // slice two rows (index must be sorted)  f.row(Seq(\u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;):_*) // another way to select // res149: Frame[String, String, Int] = [2 x 2] // x y // -- -- // a -\u0026gt; 1 NA // c -\u0026gt; NA 4 // A more explict way to slice with keys is as follows, and you can specify whether the right bound is inclusive or exclusive. Again, to slice, the index keys must be ordered.\nf.rowSliceBy(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, inclusive=false) // res150: Frame[String, String, Int] = [1 x 2] // x y // -- -- // a -\u0026gt; 1 NA //  f.colSliceBy(\u0026#34;x\u0026#34;, \u0026#34;x\u0026#34;, inclusive=true) // res151: Frame[String, String, Int] = [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // The row and col methods are used under the hood for the apply method:\nf(\u0026#34;a\u0026#34;, \u0026#34;x\u0026#34;) // extract a one-element frame by keys // res152: Frame[String, String, Int] = [1 x 1] // x // -- // a -\u0026gt; 1 // // extract a one-element frame by keys  f(\u0026#34;a\u0026#34;-\u0026gt;\u0026#34;b\u0026#34;, \u0026#34;x\u0026#34;) // two-row, one-column frame // res153: Frame[String, String, Int] = [2 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // // two-row, one-column frame  f(Vec(\u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;).toArray, \u0026#34;x\u0026#34;) // same as above, but extracting, not slicing // res154: Frame[String, String, Int] = [2 x 1] // x // -- // a -\u0026gt; 1 // c -\u0026gt; NA // The methods of extracting multiple rows shown above can of course be done on columns as well.\nYou can also split up the Frame by key or index:\nf.colSplitAt(1) // split into two frames at column 1 // res155: (Frame[String, String, Int], Frame[String, String, Int]) = ( // [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // , // [3 x 1] // y // -- // a -\u0026gt; NA // b -\u0026gt; 3 // c -\u0026gt; 4 // // ) // split into two frames at column 1  f.colSplitBy(\u0026#34;y\u0026#34;) // res156: (Frame[String, String, Int], Frame[String, String, Int]) = ( // [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // , // [3 x 1] // y // -- // a -\u0026gt; NA // b -\u0026gt; 3 // c -\u0026gt; 4 // // )  f.rowSplitAt(1) // res157: (Frame[String, String, Int], Frame[String, String, Int]) = ( // [1 x 2] // x y // -- -- // a -\u0026gt; 1 NA // , // [2 x 2] // x y // -- -- // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // )  f.rowSplitBy(\u0026#34;b\u0026#34;) // res158: (Frame[String, String, Int], Frame[String, String, Int]) = ( // [1 x 2] // x y // -- -- // a -\u0026gt; 1 NA // , // [2 x 2] // x y // -- -- // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // ) You extract some number of rows or columns:\nf.head(2) // operates on rows // res159: Frame[String, String, Int] = [2 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // // operates on rows  f.tail(2) // res160: Frame[String, String, Int] = [2 x 2] // x y // -- -- // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 //  f.headCol(1) // operates on cols // res161: Frame[String, String, Int] = [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // // operates on cols  f.tailCol(1) // res162: Frame[String, String, Int] = [3 x 1] // y // -- // a -\u0026gt; NA // b -\u0026gt; 3 // c -\u0026gt; 4 // Or the first \u0026amp; last of some key (which is helpful when you’ve got a multi-key index):\nf.first(\u0026#34;b\u0026#34;) // first row indexed by \u0026#34;b\u0026#34; key // res163: Series[String, Int] = [2 x 1] // x -\u0026gt; 2 // y -\u0026gt; 3 // // first row indexed by \u0026#34;b\u0026#34; key  f.last(\u0026#34;b\u0026#34;) // last row indexed by \u0026#34;b\u0026#34; key // res164: Series[String, Int] = [2 x 1] // x -\u0026gt; 2 // y -\u0026gt; 3 // // last row indexed by \u0026#34;b\u0026#34; key  f.firstCol(\u0026#34;x\u0026#34;) // res165: Series[String, Int] = [3 x 1] // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA //  f.lastCol(\u0026#34;x\u0026#34;) // res166: Series[String, Int] = [3 x 1] // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // There are a few other methods of extracting data:\nimport org.saddle.linalg._ f.filter { case s =\u0026gt; s.toVec.map(_.toDouble).mean2 \u0026gt; 2.0 } // any column whose series satisfies predicate // res167: Frame[String, String, Int] = Empty Frame // any column whose series satisfies predicate  f.filterIx { case x =\u0026gt; x == \u0026#34;x\u0026#34; } // col where index matches key \u0026#34;x\u0026#34; // res168: Frame[String, String, Int] = [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // // col where index matches key \u0026#34;x\u0026#34;  f.where(Vec(false, true)) // extract second column // res169: Frame[String, String, Int] = [3 x 1] // y // -- // a -\u0026gt; NA // b -\u0026gt; 3 // c -\u0026gt; 4 // There are analogous methods to operate on rows rather then columns:\nrfilter rfilterIx rwhere etc\u0026hellip; in general, methods operate on a column-wise basis, whereas the r-counterpart does so on a row-wise basis.\nYou can drop cols (rows) containing any NA values:\nf.dropNA // res170: Frame[String, String, Int] = Empty Frame  f.rdropNA // res171: Frame[String, String, Int] = [1 x 2] // x y // -- -- // b -\u0026gt; 2 3 // Let’s take a look at some operations we can do with Frames. We can do all the normal binary math operations with Frames, with either a scalar value or with another Frame. When two frames are involved, they are reindexed along both axes to match the outer join of their indices, but any missing observation in either will carry through the calculations.\nf + 1 // res172: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 2 NA // b -\u0026gt; 3 4 // c -\u0026gt; NA 5 //  f * f // res173: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 4 9 // c -\u0026gt; NA 16 //  val g = Frame(\u0026#34;y\u0026#34;-\u0026gt;Series(\u0026#34;b\u0026#34;-\u0026gt;5, \u0026#34;d\u0026#34;-\u0026gt;10)) // g: Frame[String, String, Int] = [2 x 1] // y // -- // b -\u0026gt; 5 // d -\u0026gt; 10 //  f + g // one non-NA entry, (\u0026#34;b\u0026#34;, \u0026#34;y\u0026#34;, 8) // res174: Frame[String, String, Int] = [4 x 2] // x y // -- -- // a -\u0026gt; NA NA // b -\u0026gt; NA 8 // c -\u0026gt; NA NA // d -\u0026gt; NA NA // You can effectively supply your own binary frame operation using joinMap, which lets you control the join style on rows and columns:\nf.joinMap(g, rhow=index.LeftJoin, chow=index.LeftJoin) { case (x, y) =\u0026gt; x + y } // res175: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; NA NA // b -\u0026gt; NA 8 // c -\u0026gt; NA NA // If you want simply to align one frame to another without performing an operation, use the following method:\nval (fNew, gNew) = f.align(g, rhow=index.LeftJoin, chow=index.OuterJoin) // fNew: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // gNew: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; NA NA // b -\u0026gt; NA 5 // c -\u0026gt; NA NA // If you want to treat a Frame as a matrix to use in linear algebraic fashion, call the toMat method.\nWe can sort a frame in various ways:\nf.sortedRIx // sorted by row index // res176: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // sorted by row index  f.sortedCIx // sorted by col index // res177: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // sorted by col index  f.sortedRows(0,1) // sort rows by (primary) col 0 and (secondary) col 1 // res178: Frame[String, String, Int] = [3 x 2] // x y // -- -- // c -\u0026gt; NA 4 // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // // sort rows by (primary) col 0 and (secondary) col 1  f.sortedCols(1,0) // sort cols by (primary) row 1 and (secondary) row 0 // res179: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // We can also sort by an ordering provided by the result of a function acting on rows or cols:\nf.sortedRowsBy { case r =\u0026gt; r.at(0) } // sort rows by first element of row // res180: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // sort rows by first element of row  f.sortedColsBy { case c =\u0026gt; c.at(0) } // sort cols by first element of col // res181: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // There are several mapping functions:\nf.mapValues { case t =\u0026gt; t + 1 } // add one to each element of frame // res182: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 2 NA // b -\u0026gt; 3 4 // c -\u0026gt; NA 5 // // add one to each element of frame  import org.saddle.linalg._ f.mapVec { case v =\u0026gt; v.map(_.toDouble).demeaned } // map over each col vec of the frame // res183: Frame[String, String, Double] = [3 x 2] // x y // -- -- // a -\u0026gt; NA NA // b -\u0026gt; NA NA // c -\u0026gt; NA NA // // map over each col vec of the frame  f.reduce { case s =\u0026gt; s.toVec.map(_.toDouble).mean2 } // collapse each col series to a single value // res184: Series[String, Double] = [2 x 1] // x -\u0026gt; NA // y -\u0026gt; NA // // collapse each col series to a single value  f.transform { case s =\u0026gt; s.reversed } // transform each series; outerjoin results // res185: Frame[String, String, Int] = [3 x 2] // x y // -- -- // c -\u0026gt; NA 4 // b -\u0026gt; 2 3 // a -\u0026gt; 1 NA // We can mask out values:\nf.mask(_ \u0026gt; 2) // mask out values \u0026gt; 2 f.mask(Vec(false, true, true)) // mask out rows 1 \u0026amp; 2 (keep row 0) Columns (rows) containing only NA values can be dropped as follows:\nf.mask(Vec(true, false, false)).rsqueeze // drop rows containing NA values // res186: Frame[String, String, Int] = [2 x 2] // x y // -- -- // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // drop rows containing NA values  f.rmask(Vec(false, true)).squeeze // takes \u0026#34;x\u0026#34; column // res187: Frame[String, String, Int] = [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // We can groupBy in order to combine or transform:\nimport org.saddle.linalg._ f.groupBy(_ == \u0026#34;a\u0026#34;).combine(_.count) // # obs in each column that have/not row key \u0026#34;a\u0026#34; // res188: Frame[Boolean, String, Int] = [2 x 2] // x y // -- -- // false -\u0026gt; 1 2 // true -\u0026gt; 1 0 // // # obs in each column that have/not row key \u0026#34;a\u0026#34;  f.groupBy(_ == \u0026#34;a\u0026#34;).transform(_.map(_.toDouble).demeaned) // contrived, but you get the idea hopefully! // res189: Frame[String, String, Double] = [3 x 2] // x y // ------ ------- // a -\u0026gt; 0.0000 NA // b -\u0026gt; NA -0.5000 // c -\u0026gt; NA 0.5000 // We can join against another frame, or against a series.\nf.rconcat(g, how=index.LeftJoin) // res190: Frame[String, String, Int] = [3 x 3] // x y y // -- -- -- // a -\u0026gt; 1 NA NA // b -\u0026gt; 2 3 5 // c -\u0026gt; NA 4 NA //  f.concat(g, how=index.LeftJoin) // res191: Frame[String, String, Int] = [5 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // b -\u0026gt; NA 5 // d -\u0026gt; NA 10 //  f.cbind(g, how=index.LeftJoin) // res192: Frame[String, String, Int] = [3 x 3] // x y y // -- -- -- // a -\u0026gt; 1 NA NA // b -\u0026gt; 2 3 5 // c -\u0026gt; NA 4 NA //  f.rbind(g, how=index.LeftJoin) // res193: Frame[String, String, Int] = [5 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // b -\u0026gt; NA 5 // d -\u0026gt; NA 10 // Btw, to join a Frame to a series, the call looks like this:\ns.joinF(g, how=index.LeftJoin) // res194: Frame[String, Int, Int] = [3 x 2] // 0 1 // -- -- // b -\u0026gt; 3 5 // b -\u0026gt; 4 5 // d -\u0026gt; NA 10 // "}]