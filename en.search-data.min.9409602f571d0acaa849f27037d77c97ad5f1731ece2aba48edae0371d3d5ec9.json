[{"id":0,"href":"/saddle/docs/io/csv/","title":"CSV","section":"Getting data in and out of saddle","content":"CSV Parser #  Saddle features a very fast CSV parser. It thrives to allocate as little as possible and make as few branching as possible during parsing. E.g. it can parse numeric tables without ever allocating a String (except for the header).\nThe CSV parsing logic itself is published in the saddle-io module which is a dependency free module. The saddle specific parts are in the saddle-core module.\nimport scala.io.Source import org.saddle._ val irisURL = \u0026#34;https://gist.githubusercontent.com/pityka/d05bb892541d71c2a06a0efb6933b323/raw/639388c2cbc2120a14dcf466e85730eb8be498bb/iris.csv\u0026#34; // irisURL: String = \u0026#34;https://gist.githubusercontent.com/pityka/d05bb892541d71c2a06a0efb6933b323/raw/639388c2cbc2120a14dcf466e85730eb8be498bb/iris.csv\u0026#34; val iris : Frame[Int,String,Double] = csv.CsvParser.parseInputStreamWithHeader[Double]( inputStream = new java.net.URL(irisURL).openStream, cols = List(0,1,2,3), recordSeparator = \u0026#34;\\n\u0026#34;).toOption.get // iris: Frame[Int, String, Double] = [150 x 4] // sepal_length sepal_width petal_length petal_width // ------------ ----------- ------------ ----------- // 0 -\u0026gt; 5.1000 3.5000 1.4000 0.2000 // 1 -\u0026gt; 4.9000 3.0000 1.4000 0.2000 // 2 -\u0026gt; 4.7000 3.2000 1.3000 0.2000 // 3 -\u0026gt; 4.6000 3.1000 1.5000 0.2000 // 4 -\u0026gt; 5.0000 3.6000 1.4000 0.2000 // ... // 145 -\u0026gt; 6.7000 3.0000 5.2000 2.3000 // 146 -\u0026gt; 6.3000 2.5000 5.0000 1.9000 // 147 -\u0026gt; 6.5000 3.0000 5.2000 2.0000 // 148 -\u0026gt; 6.2000 3.4000 5.4000 2.3000 // 149 -\u0026gt; 5.9000 3.0000 5.1000 1.8000 // Limitations #   recordSeparator must be a String of length one or two. fieldSeparator must be a single Char doubled quoted quotes are not turned back into a single quote. The csv RFC states that quoted quotes (\u0026quot; hi \u0026ldquo;quote\u0026rdquo; \u0026ldquo;) must be doubled (\u0026rdquo; hi \u0026ldquo;\u0026ldquo;quote\u0026rdquo;\u0026rdquo; \u0026ldquo;). These are returned as doubled. The csv parser is tuned for fast parsing of trusted (conforming) input. Parsing arbitrarily broken CSV files is not in scope.  CSV Writer #  There is a simple csv writer provided in the org.saddle.csv.CsvWriter object.\n"},{"id":1,"href":"/saddle/docs/getting_started/","title":"Getting started","section":"Docs","content":"Add any of these lines to your build.sbt:\n// The core library libraryDependencies += \u0026#34;io.github.pityka\u0026#34; %% \u0026#34;saddle-core\u0026#34; % \u0026#34;4.0.0-M11\u0026#34; // Inlined binary operation instances for Mat and Vec libraryDependencies += \u0026#34;io.github.pityka\u0026#34; %% \u0026#34;saddle-ops-inlined\u0026#34; % \u0026#34;4.0.0-M11\u0026#34; // Linear algebra interface to BLAS libraryDependencies += \u0026#34;io.github.pityka\u0026#34; %% \u0026#34;saddle-linalg\u0026#34; % \u0026#34;4.0.0-M11\u0026#34; // Binary representation of data frames and matrices libraryDependencies += \u0026#34;io.github.pityka\u0026#34; %% \u0026#34;saddle-binary\u0026#34; % \u0026#34;4.0.0-M11\u0026#34; // Circe Encoder and Decoder instances libraryDependencies += \u0026#34;io.github.pityka\u0026#34; %% \u0026#34;saddle-circe\u0026#34; % \u0026#34;4.0.0-M11\u0026#34; // Jsoniter-scala codec instances libraryDependencies += \u0026#34;io.github.pityka\u0026#34; %% \u0026#34;saddle-jsoniter\u0026#34; % \u0026#34;4.0.0-M11\u0026#34; // Interface to joda time (not maintained) libraryDependencies += \u0026#34;io.github.pityka\u0026#34; %% \u0026#34;saddle-time\u0026#34; % \u0026#34;4.0.0-M11\u0026#34; // Interface to EJML (not maintained) libraryDependencies += \u0026#34;io.github.pityka\u0026#34; %% \u0026#34;saddle-stats\u0026#34; % \u0026#34;4.0.0-M11\u0026#34; Dependencies #  The actively maintained artifacts have minimal dependencies:\n saddle-io has no dependency (not even saddle-core) saddle-core depends on cats-kernel saddle-linalg depends on a fork of netlib-java saddle-binary depends on ujson saddle-circe depends on circe saddle-jsoniter depends on jsoniter-scala  Example: SVD on the Iris dataset #  import scala.io.Source import org.saddle._ val irisURL = \u0026#34;https://gist.githubusercontent.com/pityka/d05bb892541d71c2a06a0efb6933b323/raw/639388c2cbc2120a14dcf466e85730eb8be498bb/iris.csv\u0026#34; // irisURL: String = \u0026#34;https://gist.githubusercontent.com/pityka/d05bb892541d71c2a06a0efb6933b323/raw/639388c2cbc2120a14dcf466e85730eb8be498bb/iris.csv\u0026#34; val iris : Frame[Int,String,Double] = csv.CsvParser.parseInputStreamWithHeader[Double]( inputStream = new java.net.URL(irisURL).openStream, cols = List(0,1,2,3), recordSeparator = \u0026#34;\\n\u0026#34;).toOption.get // iris: Frame[Int, String, Double] = [150 x 4] // sepal_length sepal_width petal_length petal_width // ------------ ----------- ------------ ----------- // 0 -\u0026gt; 5.1000 3.5000 1.4000 0.2000 // 1 -\u0026gt; 4.9000 3.0000 1.4000 0.2000 // 2 -\u0026gt; 4.7000 3.2000 1.3000 0.2000 // 3 -\u0026gt; 4.6000 3.1000 1.5000 0.2000 // 4 -\u0026gt; 5.0000 3.6000 1.4000 0.2000 // ... // 145 -\u0026gt; 6.7000 3.0000 5.2000 2.3000 // 146 -\u0026gt; 6.3000 2.5000 5.0000 1.9000 // 147 -\u0026gt; 6.5000 3.0000 5.2000 2.0000 // 148 -\u0026gt; 6.2000 3.4000 5.4000 2.3000 // 149 -\u0026gt; 5.9000 3.0000 5.1000 1.8000 //  import org.saddle.linalg._ val centered = iris.mapVec(_.demeaned) // centered: Frame[Int, String, Double] = [150 x 4] // sepal_length sepal_width petal_length petal_width // ------------ ----------- ------------ ----------- // 0 -\u0026gt; -0.7433 0.4460 -2.3587 -0.9987 // 1 -\u0026gt; -0.9433 -0.0540 -2.3587 -0.9987 // 2 -\u0026gt; -1.1433 0.1460 -2.4587 -0.9987 // 3 -\u0026gt; -1.2433 0.0460 -2.2587 -0.9987 // 4 -\u0026gt; -0.8433 0.5460 -2.3587 -0.9987 // ... // 145 -\u0026gt; 0.8567 -0.0540 1.4413 1.1013 // 146 -\u0026gt; 0.4567 -0.5540 1.2413 0.7013 // 147 -\u0026gt; 0.6567 -0.0540 1.4413 0.8013 // 148 -\u0026gt; 0.3567 0.3460 1.6413 1.1013 // 149 -\u0026gt; 0.0567 -0.0540 1.3413 0.6013 // val SVDResult(u, s, vt) = centered.toMat.svd(2) // u: Mat[Double] = [150 x 2] // 0.1070 0.0544 // 0.1082 -0.0282 // 0.1152 -0.0229 // 0.1095 -0.0518 // ... // -0.0608 -0.0624 // -0.0703 0.0131 // -0.0758 0.0193 // -0.0554 -0.0471 // // s: Vec[Double] = [2 x 1] // 25.0899 // 6.0079 // // vt: Mat[Double] = [2 x 4] // -0.3616 0.0823 -0.8566 -0.3588 // 0.6565 0.7297 -0.1758 -0.0747 // val pca = u.mDiagFromRight(s).toFrame // pca: Frame[Int, Int, Double] = [150 x 2] // 0 1 // ------- ------- // 0 -\u0026gt; 2.6842 0.3266 // 1 -\u0026gt; 2.7154 -0.1696 // 2 -\u0026gt; 2.8898 -0.1373 // 3 -\u0026gt; 2.7464 -0.3111 // 4 -\u0026gt; 2.7286 0.3339 // ... // 145 -\u0026gt; -1.9440 0.1874 // 146 -\u0026gt; -1.5257 -0.3750 // 147 -\u0026gt; -1.7640 0.0785 // 148 -\u0026gt; -1.9016 0.1159 // 149 -\u0026gt; -1.3897 -0.2829 //  val joined = iris.rconcat(pca.mapColIndex(i =\u0026gt; s\u0026#34;PCA$i\u0026#34;)) // joined: Frame[Int, String, Double] = [150 x 6] // sepal_length sepal_width petal_length petal_width PCA0 PCA1 // ------------ ----------- ------------ ----------- ------- ------- // 0 -\u0026gt; 5.1000 3.5000 1.4000 0.2000 2.6842 0.3266 // 1 -\u0026gt; 4.9000 3.0000 1.4000 0.2000 2.7154 -0.1696 // 2 -\u0026gt; 4.7000 3.2000 1.3000 0.2000 2.8898 -0.1373 // 3 -\u0026gt; 4.6000 3.1000 1.5000 0.2000 2.7464 -0.3111 // 4 -\u0026gt; 5.0000 3.6000 1.4000 0.2000 2.7286 0.3339 // ... // 145 -\u0026gt; 6.7000 3.0000 5.2000 2.3000 -1.9440 0.1874 // 146 -\u0026gt; 6.3000 2.5000 5.0000 1.9000 -1.5257 -0.3750 // 147 -\u0026gt; 6.5000 3.0000 5.2000 2.0000 -1.7640 0.0785 // 148 -\u0026gt; 6.2000 3.4000 5.4000 2.3000 -1.9016 0.1159 // 149 -\u0026gt; 5.9000 3.0000 5.1000 1.8000 -1.3897 -0.2829 // val reducedByColumn = joined.reduce(_.values.mean) // reducedByColumn: Series[String, Double] = [6 x 1] // sepal_length -\u0026gt; 5.8433 // sepal_width -\u0026gt; 3.0540 // petal_length -\u0026gt; 3.7587 // petal_width -\u0026gt; 1.1987 // PCA0 -\u0026gt; -0.0000 // PCA1 -\u0026gt; 0.0000 // val reducedByRow = joined.rreduce(_.values.max) // reducedByRow: Series[Int, scalar.Scalar[Double]] = [150 x 1] // 0 -\u0026gt; 5.1 // 1 -\u0026gt; 4.9 // 2 -\u0026gt; 4.7 // 3 -\u0026gt; 4.6 // 4 -\u0026gt; 5.0 // ... // 145 -\u0026gt; 6.7 // 146 -\u0026gt; 6.3 // 147 -\u0026gt; 6.5 // 148 -\u0026gt; 6.2 // 149 -\u0026gt; 5.9 // "},{"id":2,"href":"/saddle/docs/imports/","title":"Imports","section":"Docs","content":"Imports #  You most likely need the following two imports:\nimport org.saddle._ import org.saddle.order._ Note that org.saddle.order._ imports cats.kernel.Order[_] typeclass instances into the scope. If you import cats instances an other way then you should not import org.saddle.order._.\nThe Order[Double] and Order[Float] instances in org.saddle.order define a total ordering and order NaN above all other values, consistent with java.lang.Double.compare.\n"},{"id":3,"href":"/saddle/docs/io/json/","title":"JSON","section":"Getting data in and out of saddle","content":"Saddle provides type classes for circe and jsoniter scala in the saddle-circe and saddle-jsoniter modules.\nCirce #  The wildcard import import org.saddle.circe._ will import the necessary implicits for circe.\njsoniter-scala #  The wildcard import import org.saddle.jsoniter._ will import the necessary implicits for jsoniter.\n"},{"id":4,"href":"/saddle/docs/datastructures/2_vec/","title":"Vector","section":"Data structures","content":"1D vector: Vec[T] #  import org.saddle._ import org.saddle.order._ Factories #  import org.saddle._ Vec(1, 2, 3) // res0: Vec[Int] = [3 x 1] // 1 // 2 // 3 // Vec(1 to 3 : _*) // res1: Vec[Int] = [3 x 1] // 1 // 2 // 3 // Vec(Array(1,2,3)) // res2: Vec[Int] = [3 x 1] // 1 // 2 // 3 // Vec.empty[Double] // res3: Vec[Double] = Empty Vec  vec.ones(2) // res4: Vec[Double] = [2 x 1] // 1.0000 // 1.0000 // vec.zeros(3) // res5: Vec[Double] = [3 x 1] // 0.0000 // 0.0000 // 0.0000 // vec.rand(20) // res6: Vec[Double] = [20 x 1] // 0.9607 // 0.3239 // 0.2379 // 0.5219 // 0.1563 // ... // 0.4514 // 0.8897 // 0.6453 // 0.4641 // 0.9444 // Operations #  import org.saddle.ops.BinOps._ Vec(1,2,3) + Vec(4,5,6) // res7: Vec[Int] = [3 x 1] // 5 // 7 // 9 // Vec(1,2,3) * Vec(4,5,6) // res8: Vec[Int] = [3 x 1] // 4 // 10 // 18 // Vec(1,2,3) ** Vec(4,5,6) // res9: Vec[Int] = [3 x 1] // 1 // 32 // 729 // Note above, that you have to import that BinOp instances.\nAn alternative set of instances are also available which inline the innermost in Mat and Vec operations:\n// The macros package contains instances where the innermost loop is inlined. import org.saddle._ import org.saddle.macros.BinOps._ Vec(1,2,3) + Vec(4,5,6) // res11: Vec[Int] = [3 x 1] // 5 // 7 // 9 // Vec(1,2,3) * Vec(4,5,6) // res12: Vec[Int] = [3 x 1] // 4 // 10 // 18 // Vec(1,2,3) ** Vec(4,5,6) // res13: Vec[Int] = [3 x 1] // 1 // 32 // 729 // Slicing #  import org.saddle._ import org.saddle.ops.BinOps._ Vec(1,2,3).at(2) // Boxes and keeps NA // res15: scalar.Scalar[Int] = Value(el = 3) // Boxes and keeps NA Vec(1,2,3).raw(2) // res16: Int = 3 Vec(1,2,3).apply(2) // same as raw // res17: Int = 3 // same as raw Vec(1,2,3).take(0,2) // res18: Vec[Int] = [2 x 1] // 1 // 3 // Vec(1,2,3).take(1 -\u0026gt; *) // res19: Vec[Int] = [2 x 1] // 2 // 3 // Vec(1,2,3).take(* -\u0026gt; 1) // res20: Vec[Int] = [2 x 1] // 1 // 2 // "},{"id":5,"href":"/saddle/docs/datastructures/","title":"Data structures","section":"Docs","content":"Saddle is focused around the following five data structures:\n a 1D array (Vec) a 2D array (Mat) an index (Index) a 1D array with an index (Series) a 2D array with an index for each dimensions (Frame)  Vec and Mat are stored as a contiguous array. Index is stored as a specialized hash map. Series is the product type of Index and Vec. Frame is stored as two Index and a sequence of Vec-s (column-wise).\n"},{"id":6,"href":"/saddle/docs/datastructures/3_series/","title":"Indexed vector","section":"Data structures","content":"1D vector with index: Series[K,V] #  A Series combines a Vec with an Index that provides an ordered key-value mapping. We’ll talk more about the details of Index later.\nThe key type of a must have a natural ordering (ie, an Ordering of that type within the implicit scope). However, the Series maintains the order in which its data was supplied unless ordered othewise.\nLet’s look at a few constructions:\nimport org.saddle.order._ import org.saddle._ import org.saddle.ops.BinOps._ // we already know we can convert a Vec Series(Vec(32, 12, 9)) // res0: Series[Int, Int] = [3 x 1] // 0 -\u0026gt; 32 // 1 -\u0026gt; 12 // 2 -\u0026gt; 9 //  // we can pass a pair of tuples Series(\u0026#34;a\u0026#34; -\u0026gt; 1, \u0026#34;b\u0026#34; -\u0026gt; 2, \u0026#34;c\u0026#34; -\u0026gt; 3) // res1: Series[String, Int] = [3 x 1] // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; 3 //  // any series of tuples will work, eg: Series(List(\u0026#34;a\u0026#34; -\u0026gt; 1, \u0026#34;b\u0026#34; -\u0026gt; 2, \u0026#34;c\u0026#34; -\u0026gt; 3) : _*) // res2: Series[String, Int] = [3 x 1] // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; 3 //  // can pass data and index separately: Series(Vec(1,2,3), Index(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)) // res3: Series[String, Int] = [3 x 1] // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; 3 //  // you can create an empty Series like so: Series.empty[String, Int] // res4: Series[String, Int] = Empty Series  // supplied order is maintained: Series(Vec(1,2,3), Index(\u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;)) // res5: Series[String, Int] = [3 x 1] // c -\u0026gt; 1 // b -\u0026gt; 2 // a -\u0026gt; 3 //  // unlike map, multiple keys are entirely fine: Series(Vec(1,2,3,4), Index(\u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)) // res6: Series[String, Int] = [4 x 1] // c -\u0026gt; 1 // b -\u0026gt; 2 // a -\u0026gt; 3 // b -\u0026gt; 4 // With construction out of the way, let’s look at a few ways we can get data out of a Series.\nval q = Series(Vec(1,3,2,4), Index(\u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)) // q: Series[String, Int] = [4 x 1] // c -\u0026gt; 1 // b -\u0026gt; 3 // a -\u0026gt; 2 // b -\u0026gt; 4 //  // get the values or index  q.values // res7: Vec[Int] = [4 x 1] // 1 // 3 // 2 // 4 //  q.index // res8: Index[String] = [Index 4 x 1] // c // b // a // b //  // extract value by numerical offset  q.at(2) // res9: scalar.Scalar[Int] = Value(el = 2)  q.at(2,3,1) // res10: Series[String, Int] = [3 x 1] // a -\u0026gt; 2 // b -\u0026gt; 4 // b -\u0026gt; 3 //  // or extract key  q.keyAt(2) // res11: scalar.Scalar[String] = Value(el = \u0026#34;a\u0026#34;)  q.keyAt(2,3,1) // res12: Index[String] = [Index 3 x 1] // a // b // b //  // sort by index ordering  q.sortedIx // res13: Series[String, Int] = [4 x 1] // a -\u0026gt; 2 // b -\u0026gt; 3 // b -\u0026gt; 4 // c -\u0026gt; 1 //  // sort by value ordering  q.sorted // res14: Series[String, Int] = [4 x 1] // c -\u0026gt; 1 // a -\u0026gt; 2 // b -\u0026gt; 3 // b -\u0026gt; 4 //  // extract elements matching the index  q(\u0026#34;b\u0026#34;) // res15: Series[String, Int] = [2 x 1] // b -\u0026gt; 3 // b -\u0026gt; 4 //  q(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;) // res16: Series[String, Int] = [3 x 1] // a -\u0026gt; 2 // b -\u0026gt; 3 // b -\u0026gt; 4 //  // notice ordering subtleties:  q(\u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;) // res17: Series[String, Int] = [3 x 1] // b -\u0026gt; 3 // b -\u0026gt; 4 // a -\u0026gt; 2 //  // get first or last values  q.first // res18: scalar.Scalar[Int] = Value(el = 1)  q.last // res19: scalar.Scalar[Int] = Value(el = 4)  // or key  q.firstKey // res20: scalar.Scalar[String] = Value(el = \u0026#34;c\u0026#34;)  q.lastKey // res21: scalar.Scalar[String] = Value(el = \u0026#34;b\u0026#34;)  // \u0026#34;reindex\u0026#34; to a new index:  q.reindex(Index(\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;)) // res22: Series[String, Int] = [3 x 1] // a -\u0026gt; 2 // c -\u0026gt; 1 // d -\u0026gt; NA //  // or just by a sequence of keys:  q.reindex(\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;) // res23: Series[String, Int] = [3 x 1] // a -\u0026gt; 2 // c -\u0026gt; 1 // d -\u0026gt; NA //  // notice that \u0026#39;slicing\u0026#39; ignores unknown keys:  q(\u0026#34;a\u0026#34;, \u0026#34;d\u0026#34;) // res24: Series[String, Int] = [1 x 1] // a -\u0026gt; 2 // // we cannot reindex with \u0026#34;b\u0026#34;, because it isn\u0026#39;t unique. // (the problem is, which \u0026#34;b\u0026#34; would we choose?)  q.reindex(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;) // java.lang.IllegalArgumentException: requirement failed: Could not reindex unambiguously // at scala.Predef$.require(Predef.scala:337) // at org.saddle.Index.getIndexer(Index.scala:436) // at org.saddle.Index.getIndexer$(Index.scala:432) // at org.saddle.index.IndexAny.getIndexer(IndexAny.scala:28) // at org.saddle.Series$mcI$sp.reindex$mcI$sp(Series.scala:258) // at org.saddle.Series$mcI$sp.reindex$mcI$sp(Series.scala:267) // at repl.MdocSession$MdocApp$$anonfun$1.apply(3_series.md:102) // at repl.MdocSession$MdocApp$$anonfun$1.apply(3_series.md:102) // we can \u0026#34;reset\u0026#34; the index to integer labels  q.resetIndex // res25: Series[Int, Int] = [4 x 1] // 0 -\u0026gt; 1 // 1 -\u0026gt; 3 // 2 -\u0026gt; 2 // 3 -\u0026gt; 4 //  // or to a new index altogether  q.setIndex(Index(\u0026#34;w\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;)) // res26: Series[String, Int] = [4 x 1] // w -\u0026gt; 1 // x -\u0026gt; 3 // y -\u0026gt; 2 // z -\u0026gt; 4 //  // to \u0026#39;slice\u0026#39;, we need a sorted index; slice is inclusive by default  val s = q.sortedIx // s: Series[String, Int] = [4 x 1] // a -\u0026gt; 2 // b -\u0026gt; 3 // b -\u0026gt; 4 // c -\u0026gt; 1 //  s.sliceBy(\u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;) // res27: Series[String, Int] = [3 x 1] // b -\u0026gt; 3 // b -\u0026gt; 4 // c -\u0026gt; 1 //  // syntactic sugar is provided:  s.sliceBy(\u0026#34;b\u0026#34; -\u0026gt; \u0026#34;c\u0026#34;) // res28: Series[String, Int] = [3 x 1] // b -\u0026gt; 3 // b -\u0026gt; 4 // c -\u0026gt; 1 //  s.sliceBy(* -\u0026gt; \u0026#34;b\u0026#34;) // res29: Series[String, Int] = [3 x 1] // a -\u0026gt; 2 // b -\u0026gt; 3 // b -\u0026gt; 4 //  // where slice is by offset, exclusive by default, and the // index doesn\u0026#39;t have to be sorted:  q.slice(0,2) // res30: Series[String, Int] = [2 x 1] // c -\u0026gt; 1 // b -\u0026gt; 3 //  // there are head/tail methods:  q.head(2) // res31: Series[String, Int] = [2 x 1] // c -\u0026gt; 1 // b -\u0026gt; 3 //  q.tail(2) // res32: Series[String, Int] = [2 x 1] // a -\u0026gt; 2 // b -\u0026gt; 4 // Aside from extracting values, there are many fun ways to compute with Series. Try the following:\nq.mapValues(_ + 1) // res33: Series[String, Int] = [4 x 1] // c -\u0026gt; 2 // b -\u0026gt; 4 // a -\u0026gt; 3 // b -\u0026gt; 5 // q.mapIndex(_ + \u0026#34;x\u0026#34;) // res34: Series[String, Int] = [4 x 1] // cx -\u0026gt; 1 // bx -\u0026gt; 3 // ax -\u0026gt; 2 // bx -\u0026gt; 4 // q.shift(1) // res35: Series[String, Int] = [4 x 1] // c -\u0026gt; NA // b -\u0026gt; 1 // a -\u0026gt; 3 // b -\u0026gt; 2 // q.filter(_ \u0026gt; 2) // res36: Series[String, Int] = [2 x 1] // b -\u0026gt; 3 // b -\u0026gt; 4 // q.filterIx(_ != \u0026#34;b\u0026#34;) // res37: Series[String, Int] = [2 x 1] // c -\u0026gt; 1 // a -\u0026gt; 2 // q.filterAt { case loc =\u0026gt; loc != 1 \u0026amp;\u0026amp; loc != 3 } // res38: Series[String, Int] = [2 x 1] // c -\u0026gt; 1 // a -\u0026gt; 2 // q.find(_ == 2) // res39: Vec[Int] = [1 x 1] // 2 // q.findKey { case x =\u0026gt; x == 2 || x == 3 } // res40: Index[String] = [Index 2 x 1] // b // a // q.findOneKey { case x =\u0026gt; x == 2 || x == 3 } // res41: scalar.Scalar[String] = Value(el = \u0026#34;b\u0026#34;) q.minKey // res42: scalar.Scalar[String] = Value(el = \u0026#34;c\u0026#34;) q.contains(\u0026#34;a\u0026#34;) // res43: Boolean = true q.scanLeft(0) { case (acc, v) =\u0026gt; acc + v } // res44: Series[String, Int] = [4 x 1] // c -\u0026gt; 1 // b -\u0026gt; 4 // a -\u0026gt; 6 // b -\u0026gt; 10 // q.reversed // res45: Series[String, Int] = [4 x 1] // b -\u0026gt; 4 // a -\u0026gt; 2 // b -\u0026gt; 3 // c -\u0026gt; 1 //  val ma = q.mask(q.values \u0026gt; 2) // ma: Series[String, Int] = [4 x 1] // c -\u0026gt; 1 // b -\u0026gt; NA // a -\u0026gt; 2 // b -\u0026gt; NA // ma.hasNA // res46: Boolean = true ma.dropNA // res47: Series[String, Int] = [2 x 1] // c -\u0026gt; 1 // a -\u0026gt; 2 //  q.rolling(2, _.minKey) // res48: Series[String, scalar.Scalar[String]] = [3 x 1] // b -\u0026gt; c // a -\u0026gt; a // b -\u0026gt; a // q.splitAt(2) // res49: (Series[String, Int], Series[String, Int]) = ( // [2 x 1] // c -\u0026gt; 1 // b -\u0026gt; 3 // , // [2 x 1] // a -\u0026gt; 2 // b -\u0026gt; 4 // // ) q.sortedIx.splitBy(\u0026#34;b\u0026#34;) // res50: (Series[String, Int], Series[String, Int]) = ( // [1 x 1] // a -\u0026gt; 2 // , // [3 x 1] // b -\u0026gt; 3 // b -\u0026gt; 4 // c -\u0026gt; 1 // // ) We can of course convert to a Vec or a Seq if we need to. The Series.toSeq method yields a sequence of key/value tuples.\nq.toVec // res51: Vec[Int] = [4 x 1] // 1 // 3 // 2 // 4 //  q.toSeq // res52: IndexedSeq[(String, Int)] = ArraySeq( // (\u0026#34;c\u0026#34;, 1), // (\u0026#34;b\u0026#34;, 3), // (\u0026#34;a\u0026#34;, 2), // (\u0026#34;b\u0026#34;, 4) // ) We can also group by key in order to transform or combine the groupings, which themselves are Series. For example:\nq.groupBy.combine(_.sum) // res53: Series[String, Int] = [3 x 1] // a -\u0026gt; 2 // b -\u0026gt; 7 // c -\u0026gt; 1 //  q.groupBy.transform(s =\u0026gt; s - s.mean) // res54: Series[String, Double] = [4 x 1] // c -\u0026gt; 0.0000 // b -\u0026gt; -0.5000 // a -\u0026gt; 0.0000 // b -\u0026gt; 0.5000 // You can also group by another index, or by a transformation of the current index, by passing an argument into groupBy. See the Saddle API for more info.\nThe expressive nature of working with Series becomes apparent when you need to align data:\nval a = Series(Vec(1,4,2,3), Index(\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;)) // a: Series[String, Int] = [4 x 1] // a -\u0026gt; 1 // b -\u0026gt; 4 // c -\u0026gt; 2 // d -\u0026gt; 3 // val b = Series(Vec(5,2,1,8,7), Index(\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;)) // b: Series[String, Int] = [5 x 1] // b -\u0026gt; 5 // c -\u0026gt; 2 // d -\u0026gt; 1 // e -\u0026gt; 8 // f -\u0026gt; 7 //  a + b // res55: Series[String, Int] = [6 x 1] // a -\u0026gt; NA // b -\u0026gt; 9 // c -\u0026gt; 4 // d -\u0026gt; 4 // e -\u0026gt; NA // f -\u0026gt; NA // You see that the indexes have been aligned prior to operation being performed. Because there is a missing observation in each label of a, e, and f, the summation is not done and instead an NA value is inserted into the result.\nGenerally, a full-outer join is performed. So, for instance:\nval c = Series(Vec(1,4,2), Index(\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;b\u0026#34;)) // c: Series[String, Int] = [3 x 1] // a -\u0026gt; 1 // b -\u0026gt; 4 // b -\u0026gt; 2 // val d = Series(Vec(5,2,1), Index(\u0026#34;b\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;d\u0026#34;)) // d: Series[String, Int] = [3 x 1] // b -\u0026gt; 5 // b -\u0026gt; 2 // d -\u0026gt; 1 //  c + d // res56: Series[String, Int] = [6 x 1] // a -\u0026gt; NA // b -\u0026gt; 9 // b -\u0026gt; 6 // b -\u0026gt; 7 // b -\u0026gt; 4 // d -\u0026gt; NA // Most basic math and boolean operations are supported between two Series, as well as between a Series and a scalar value.\nWe mentioned joins. Let’s look at a few join operations; the result is a Frame, which we will touch on a bit later. These are similar in nature to SQL joins.\na.join(b, how=index.LeftJoin) // res57: Frame[String, Int, Int] = [4 x 2] // 0 1 // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 4 5 // c -\u0026gt; 2 2 // d -\u0026gt; 3 1 //  a.join(b, how=index.RightJoin) // res58: Frame[String, Int, Int] = [5 x 2] // 0 1 // -- -- // b -\u0026gt; 4 5 // c -\u0026gt; 2 2 // d -\u0026gt; 3 1 // e -\u0026gt; NA 8 // f -\u0026gt; NA 7 //  a.join(b, how=index.InnerJoin) // res59: Frame[String, Int, Int] = [3 x 2] // 0 1 // -- -- // b -\u0026gt; 4 5 // c -\u0026gt; 2 2 // d -\u0026gt; 3 1 //  a.join(b, how=index.OuterJoin) // res60: Frame[String, Int, Int] = [6 x 2] // 0 1 // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 4 5 // c -\u0026gt; 2 2 // d -\u0026gt; 3 1 // e -\u0026gt; NA 8 // f -\u0026gt; NA 7 // "},{"id":7,"href":"/saddle/docs/io/npy/","title":"NPY","section":"Getting data in and out of saddle","content":"Saddle provides methods to read matrices from numpy\u0026rsquo;s NPY format. It can not read all NPY files, only those which contain numeric arrays.\nSee the short API of the org.saddle.npy.Reader object for further details.\n"},{"id":8,"href":"/saddle/docs/datastructures/4_mat/","title":"2D array (matrix)","section":"Data structures","content":"Matrix: Mat[T] #  import org.saddle._ import org.saddle.order._ A Mat[T] represents a matrix of values. Internally it is stored as a single contiguous array in row-major order.\nThe row-major layout is compatible with EJML, a linear algebra library running on the JVM. If you want to use a BLAS, you can take a look in saddle-linalg.\nFactories #  import org.saddle._ Mat(2,2, Array(1,2,3,4)) // res0: Mat[Int] = [2 x 2] // 1 2 // 3 4 //  // all same:  Mat(Array(Array(1,3), Array(2,4))) // res1: Mat[Int] = [2 x 2] // 1 2 // 3 4 //  Mat(Vec(1,3), Vec(2,4)) // res2: Mat[Int] = [2 x 2] // 1 2 // 3 4 //  Mat(Array(Vec(1,3), Vec(2,4))) // res3: Mat[Int] = [2 x 2] // 1 2 // 3 4 //  // identity matrix:  mat.ident(2) // res4: Mat[Double] = [2 x 2] // 1.0000 0.0000 // 0.0000 1.0000 //  // empty matrix:  Mat.empty[Double] // res5: Mat[Double] = [0 x 0] //  // zeros:  Mat[Int](2, 2) // res6: Mat[Int] = [2 x 2] // 0 0 // 0 0 // Again, sometimes we want to create instances filled with random observations. As to Vec, we can do the following:\nmat.rand(2,2) // res7: Mat[Double] = [2 x 2] // 0.0222 0.5593 // 0.5184 0.7705 //  mat.randp(2,2) // random positive doubles // res8: Mat[Double] = [2 x 2] // 0.3432 0.4650 // 0.8351 0.9488 // // random positive doubles  mat.randn(2,2) // random normally distributed doubles // res9: Mat[Double] = [2 x 2] // -0.6479 1.0175 // -0.1122 -1.0581 // // random normally distributed doubles  mat.randn2(2,2,3,12) // random normally distributed with mean=3, stdev=12 // res10: Mat[Double] = [2 x 2] // 10.2016 23.2474 // -15.5203 8.5758 // There are a few other factory methods available:\nmat.ones(2,2) // res11: Mat[Double] = [2 x 2] // 1.0000 1.0000 // 1.0000 1.0000 //  mat.zeros(2,2) // res12: Mat[Double] = [2 x 2] // 0.0000 0.0000 // 0.0000 0.0000 //  mat.diag(Vec(1,2)) // res13: Mat[Double] = [2 x 2] // 1.0000 0.0000 // 0.0000 2.0000 // Binary operations #  Let’s look at some basic operations with Mat. As with Vec, you may perform calculations on two Mat instances, or on a Mat and a scalar value.\nimport org.saddle.ops.BinOps._ // element-wise multiplication  Mat(2,2,Array(1,2,3,4)) * Mat(2,2,Array(4,1,2,3)) // res14: Mat[Int] = [2 x 2] // 4 2 // 6 12 // Linear algebra #  Matrix multiplication, matrix-vector multiplication or other linear algebra operatoins need saddle-linalg, which depends on netlib-java. These work just on Mat[Double] and Vec[Double].\nimport org.saddle.linalg._ // matrix multiplication  Mat(2,2,Array(1d,2d,3d,4d)) mm Mat(2,2,Array(4d,1d,2d,3d)) // res15: Mat[Double] = [2 x 2] // 8.0000 7.0000 // 20.0000 15.0000 //  // matrix-vector multiplication  Mat(2,2,Array(1d,2d,3d,4d)) mv Vec(2d,1d) // res16: Vec[Double] = [2 x 1] // 4.0000 // 10.0000 //  // as expected  Mat(2,2,Array(1,2,3,4)) * 2 // res17: Mat[Int] = [2 x 2] // 2 4 // 6 8 //  Mat(2,2,Array(1,2,3,4)) + 2 // res18: Mat[Int] = [2 x 2] // 3 4 // 5 6 //  Mat(2,2,Array(1,2,3,4)) \u0026lt;\u0026lt; 2 // res19: Mat[Int] = [2 x 2] // 4 8 // 12 16 // // etc...  // transpose  Mat(2,2,Array(1,2,3,4)).T // res20: Mat[Int] = [2 x 2] // 1 3 // 2 4 //  // properties of Mat val m = Mat(2,2,Array(1,2,3,4)) // m: Mat[Int] = [2 x 2] // 1 2 // 3 4 //  m.numRows // res21: Int = 2  m.numCols // res22: Int = 2  m.isSquare // res23: Boolean = true  m.isEmpty // res24: Boolean = false Operations #  There are a few ways to extract values from a Mat.\nm.at(0,1) // res25: scalar.Scalar[Int] = Value(el = 2)  // be careful with this one!  m.raw(0,1) // res26: Int = 2  m.takeRows(0) // res27: Mat[Int] = [1 x 2] // 1 2 //  m.withoutRows(0) // res28: Mat[Int] = [1 x 2] // 3 4 //  m.takeCols(0) // res29: Mat[Int] = [2 x 1] // 1 // 3 //  m.col(0) // res30: Vec[Int] = [2 x 1] // 1 // 3 //  m.row(0) // res31: Vec[Int] = [2 x 1] // 1 // 2 //  m.rows // res32: IndexedSeq[Vec[Int]] = Vector( // [2 x 1] // 1 // 2 // , // [2 x 1] // 3 // 4 // // )  m.cols // res33: IndexedSeq[Vec[Int]] = Vector( // [2 x 1] // 1 // 3 // , // [2 x 1] // 2 // 4 // // ) Some other interesting methods on Mat:\nval m2 = Mat(2,2,Array(1,2,na[Int],4)) // m2: Mat[Int] = [2 x 2] // 1 2 // NA 4 //  m2.rowsWithNA // res34: Set[Int] = Set(1)  m2.dropRowsWithNA // res35: Mat[Int] = [1 x 2] // 1 2 //  m2.reshape(1,4) // res36: Mat[Int] = [1 x 4] // 1 2 NA 4 //  mat.rand(2,2).roundTo(2) // res37: Mat[Double] = [2 x 2] // 0.4600 0.2000 // 0.9100 0.0800 // "},{"id":9,"href":"/saddle/docs/io/binary/","title":"Binary","section":"Getting data in and out of saddle","content":"The saddle-binary module offers a saddle specific fast serialization format. Its main use is as a temporary format which can be parsed very efficiently. It can serialize Vecs, Mats, Series and Frames.\nThe entry point of these APIs are the org.saddle.binary.Writer and Reader objects.\nThe scaladoc documents the serialization format.\nAn example:\nimport org.saddle._ import org.saddle.order._ val frame = Frame( Mat(Vec(1d, 2d), Vec(3d, 4d), Vec(5d, 6d)), Index(\u0026#34;r1\u0026#34;, \u0026#34;r2\u0026#34;), Index(\u0026#34;c1\u0026#34;, \u0026#34;c2\u0026#34;, \u0026#34;c3\u0026#34;) ) // frame: Frame[String, String, Double] = [2 x 3] // c1 c2 c3 // ------ ------ ------ // r1 -\u0026gt; 1.0000 3.0000 5.0000 // r2 -\u0026gt; 2.0000 4.0000 6.0000 // val binaryFrame = org.saddle.binary.Writer.writeFrameIntoArray(frame) // binaryFrame: Either[String, Array[Byte]] = Right( // value = Array( // 83, // 65, // 68, // 68, // 76, // 69, // 1, // 0, // 89, // 0, // 0, // 0, // 123, // 34, // 100, // 97, // 116, // 97, // 116, // 121, // 112, // 101, // 34, // 58, // 34, // 100, // 111, // 117, // 98, // 108, // 101, // 34, // 44, // 34, // 99, // 111, // 108, // 105, // 120, // 34, // 58, // 91, // 34, // 99, // 49, // 34, // 44, // ... "},{"id":10,"href":"/saddle/docs/io/","title":"Getting data in and out of saddle","section":"Docs","content":"Saddle provides facilities for the following serialization formats:\n csv (read and write) npy (read) json (circe and jsoniter-scala typeclasses) a custom binary serializaton format (read and write)  "},{"id":11,"href":"/saddle/docs/datastructures/5_frame/","title":"Data frame","section":"Data structures","content":"Homogeneous table with row and column index (data frame) : Frame[RX,CX,T] #  A Frame combines a Mat with a row index and a column index which provides a way to index into the Mat.\nA Frame is represented internally as a sequence of column Vec instances all sharing the same row index.\nFactories #  import org.saddle._ import org.saddle.order._ import org.saddle.ops.BinOps._ val v = Vec(1, 2) // given the following // v: Vec[Int] = [2 x 1] // 1 // 2 // // given the following  val u = Vec(3, 4) // u: Vec[Int] = [2 x 1] // 3 // 4 //  val s = Series(Vec(1,3,2,4), Index(\u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)).sortedIx // s: Series[String, Int] = [4 x 1] // a -\u0026gt; 2 // b -\u0026gt; 3 // b -\u0026gt; 4 // c -\u0026gt; 1 //  val s2 = Series(\u0026#34;a\u0026#34; -\u0026gt; 1, \u0026#34;b\u0026#34; -\u0026gt; 2) // s2: Series[String, Int] = [2 x 1] // a -\u0026gt; 1 // b -\u0026gt; 2 //  val t = Series(\u0026#34;b\u0026#34; -\u0026gt; 3, \u0026#34;c\u0026#34; -\u0026gt; 4) // t: Series[String, Int] = [2 x 1] // b -\u0026gt; 3 // c -\u0026gt; 4 //  Frame(v, u) // two-column frame // res0: Frame[Int, Int, Int] = [2 x 2] // 0 1 // -- -- // 0 -\u0026gt; 1 3 // 1 -\u0026gt; 2 4 // // two-column frame  Frame(\u0026#34;x\u0026#34; -\u0026gt; v, \u0026#34;y\u0026#34; -\u0026gt; u) // with column index // res1: Frame[Int, String, Int] = [2 x 2] // x y // -- -- // 0 -\u0026gt; 1 3 // 1 -\u0026gt; 2 4 // // with column index  Frame(s2, t) // aligned along rows // res2: Frame[String, Int, Int] = [3 x 2] // 0 1 // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // aligned along rows  Frame(\u0026#34;x\u0026#34; -\u0026gt; s2, \u0026#34;y\u0026#34; -\u0026gt; t) // with column index // res3: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // with column index  Frame(Seq(s2, t), Index(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;)) // explicit column index // res4: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // explicit column index  Frame(Seq(v, u), Index(0, 1), Index(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;)) // row \u0026amp; col indexes specified explicitly // res5: Frame[Int, String, Int] = [2 x 2] // x y // -- -- // 0 -\u0026gt; 1 3 // 1 -\u0026gt; 2 4 // // row \u0026amp; col indexes specified explicitly  Frame(Seq(v, u), Index(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)) // col index specified // res6: Frame[Int, String, Int] = [2 x 2] // a b // -- -- // 0 -\u0026gt; 1 3 // 1 -\u0026gt; 2 4 // The factory methods which construct a Frame from columns as Series come in two flavors regarding their behavior upon non-unique indices in the series (duplicate row index values).\n The Frame.apply methods create a full cross product of the respective indices. This means that for a given value of the row index all respective items will be paired with all other, potentially leading to a combinatorial explosion of the number of rows of the resulting Frame in case of duplicated index values. The Frame.fromCols methods disambiguate the non-unique indices before joining. This avoids the combinatorial increase in the number of rows, at the cost of arbitrarily joining items with the same index value.  An example for the difference between Frame.apply and Frame.fromCols, note the rows with 0 index:\nFrame.fromCols( Series(0 -\u0026gt; 1, 2 -\u0026gt; 2, 1 -\u0026gt; 3, 0 -\u0026gt; 4), Series(1 -\u0026gt; 1, 2 -\u0026gt; 2, 0 -\u0026gt; 3, 0 -\u0026gt; 4), Series(0 -\u0026gt; 1, 1 -\u0026gt; 2, 2 -\u0026gt; 3, 0 -\u0026gt; 4) ) // res7: Frame[Int, Int, Int] = [4 x 3] // 0 1 2 // -- -- -- // 0 -\u0026gt; 1 3 1 // 2 -\u0026gt; 2 2 3 // 1 -\u0026gt; 3 1 2 // 0 -\u0026gt; 4 4 4 //  Frame.apply( Series(0 -\u0026gt; 1, 2 -\u0026gt; 2, 1 -\u0026gt; 3, 0 -\u0026gt; 4), Series(1 -\u0026gt; 1, 2 -\u0026gt; 2, 0 -\u0026gt; 3, 0 -\u0026gt; 4), Series(0 -\u0026gt; 1, 1 -\u0026gt; 2, 2 -\u0026gt; 3, 0 -\u0026gt; 4) ) // res8: Frame[Int, Int, Int] = [10 x 3] // 0 1 2 // -- -- -- // 0 -\u0026gt; 1 3 1 // 0 -\u0026gt; 1 3 4 // 0 -\u0026gt; 1 4 1 // 0 -\u0026gt; 1 4 4 // 0 -\u0026gt; 4 3 1 // 0 -\u0026gt; 4 3 4 // 0 -\u0026gt; 4 4 1 // 0 -\u0026gt; 4 4 4 // 2 -\u0026gt; 2 2 3 // 1 -\u0026gt; 3 1 2 // Operations #  You’ll notice that if an index is not provided, a default int index is set where the index ranges between 0 and the length of the data.\nIf you want to set or reset the index, these methods are your friends:\nval f = Frame(\u0026#34;x\u0026#34; -\u0026gt; s2, \u0026#34;y\u0026#34; -\u0026gt; t) // f: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 //  f.setRowIndex(org.saddle.index.IndexIntRange(f.numRows)) // res9: Frame[Int, String, Int] = [3 x 2] // x y // -- -- // 0 -\u0026gt; 1 NA // 1 -\u0026gt; 2 3 // 2 -\u0026gt; NA 4 //  f.setColIndex(Index(\u0026#34;p\u0026#34;, \u0026#34;q\u0026#34;)) // res10: Frame[String, String, Int] = [3 x 2] // p q // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 //  f.resetRowIndex // res11: Frame[Int, String, Int] = [3 x 2] // x y // -- -- // 0 -\u0026gt; 1 NA // 1 -\u0026gt; 2 3 // 2 -\u0026gt; NA 4 //  f.resetColIndex // res12: Frame[String, Int, Int] = [3 x 2] // 0 1 // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // (Note: frame f will carry through the next examples.)\nYou also have the following index transformation tools at hand:\nf.mapRowIndex { case rx =\u0026gt; rx+1 } // res13: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a1 -\u0026gt; 1 NA // b1 -\u0026gt; 2 3 // c1 -\u0026gt; NA 4 // f.mapColIndex { case cx =\u0026gt; cx+2 } // res14: Frame[String, String, Int] = [3 x 2] // x2 y2 // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // Let’s next look at how to extract data from the Frame.\nf.rowAt(2) // extract row at offset 2, as Series // res15: Series[String, Int] = [2 x 1] // x -\u0026gt; NA // y -\u0026gt; 4 // // extract row at offset 2, as Series  f.rowAt(1,2) // extract frame of rows 1 \u0026amp; 2 // res16: Frame[String, String, Int] = [2 x 2] // x y // -- -- // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // extract frame of rows 1 \u0026amp; 2  f.rowAt(1-\u0026gt;2) // extract frame of rows 1 \u0026amp; 2 // res17: Frame[String, String, Int] = [2 x 2] // x y // -- -- // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // extract frame of rows 1 \u0026amp; 2  f.colAt(1) // extract col at offset 1, as Series // res18: Series[String, Int] = [3 x 1] // a -\u0026gt; NA // b -\u0026gt; 3 // c -\u0026gt; 4 // // extract col at offset 1, as Series  f.colAt(0,1) // extract frame of cols 1 \u0026amp; 2 // res19: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // extract frame of cols 1 \u0026amp; 2  f.colAt(0-\u0026gt;1) // extract frame of cols 1 \u0026amp; 2 // res20: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // rowAt and colAt are used under the hood for the at extractor:\nf.at(1,1) // Scalar value // res21: scalar.Scalar[Int] = Value(el = 3) // Scalar value  f.at(Array(1,2), 0) // extract rows 1,2 of column 0 // res22: Series[String, Int] = [2 x 1] // b -\u0026gt; 2 // c -\u0026gt; NA // If you want more control over slicing, you can use these methods:\nf.colSlice(0,1) // frame slice consisting of column 0 // res23: Frame[String, String, Int] = [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // // frame slice consisting of column 0  f.rowSlice(0,3,2) // row slice from 0 until 3, striding by 2 // res24: Frame[String, String, Int] = [2 x 2] // x y // -- -- // a -\u0026gt; 1 NA // c -\u0026gt; NA 4 // Of course, this is an bi-indexed data structure, so we can use its indexes to select out data using keys:\nf.row(\u0026#34;a\u0026#34;) // row series \u0026#39;a\u0026#39;, with all columns // res25: Frame[String, String, Int] = [1 x 2] // x y // -- -- // a -\u0026gt; 1 NA // // row series \u0026#39;a\u0026#39;, with all columns  f.col(\u0026#34;x\u0026#34;) // col series \u0026#39;x\u0026#39;, with all rows // res26: Frame[String, String, Int] = [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // // col series \u0026#39;x\u0026#39;, with all rows  f.row(\u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;) // select two rows // res27: Frame[String, String, Int] = [2 x 2] // x y // -- -- // a -\u0026gt; 1 NA // c -\u0026gt; NA 4 // // select two rows  f.row(\u0026#34;a\u0026#34;-\u0026gt;\u0026#34;b\u0026#34;) // slice two rows (index must be sorted) // res28: Frame[String, String, Int] = [2 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // // slice two rows (index must be sorted)  f.row(Seq(\u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;):_*) // another way to select // res29: Frame[String, String, Int] = [2 x 2] // x y // -- -- // a -\u0026gt; 1 NA // c -\u0026gt; NA 4 // A more explict way to slice with keys is as follows, and you can specify whether the right bound is inclusive or exclusive. Again, to slice, the index keys must be ordered.\nf.rowSliceBy(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, inclusive=false) // res30: Frame[String, String, Int] = [1 x 2] // x y // -- -- // a -\u0026gt; 1 NA //  f.colSliceBy(\u0026#34;x\u0026#34;, \u0026#34;x\u0026#34;, inclusive=true) // res31: Frame[String, String, Int] = [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // The row and col methods are used under the hood for the apply method:\nf(\u0026#34;a\u0026#34;, \u0026#34;x\u0026#34;) // extract a one-element frame by keys // res32: Frame[String, String, Int] = [1 x 1] // x // -- // a -\u0026gt; 1 // // extract a one-element frame by keys  f(\u0026#34;a\u0026#34;-\u0026gt;\u0026#34;b\u0026#34;, \u0026#34;x\u0026#34;) // two-row, one-column frame // res33: Frame[String, String, Int] = [2 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // // two-row, one-column frame  f(Vec(\u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;).toArray, \u0026#34;x\u0026#34;) // same as above, but extracting, not slicing // res34: Frame[String, String, Int] = [2 x 1] // x // -- // a -\u0026gt; 1 // c -\u0026gt; NA // The methods of extracting multiple rows shown above can of course be done on columns as well.\nYou can also split up the Frame by key or index:\nf.colSplitAt(1) // split into two frames at column 1 // res35: (Frame[String, String, Int], Frame[String, String, Int]) = ( // [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // , // [3 x 1] // y // -- // a -\u0026gt; NA // b -\u0026gt; 3 // c -\u0026gt; 4 // // ) // split into two frames at column 1  f.colSplitBy(\u0026#34;y\u0026#34;) // res36: (Frame[String, String, Int], Frame[String, String, Int]) = ( // [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // , // [3 x 1] // y // -- // a -\u0026gt; NA // b -\u0026gt; 3 // c -\u0026gt; 4 // // )  f.rowSplitAt(1) // res37: (Frame[String, String, Int], Frame[String, String, Int]) = ( // [1 x 2] // x y // -- -- // a -\u0026gt; 1 NA // , // [2 x 2] // x y // -- -- // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // )  f.rowSplitBy(\u0026#34;b\u0026#34;) // res38: (Frame[String, String, Int], Frame[String, String, Int]) = ( // [1 x 2] // x y // -- -- // a -\u0026gt; 1 NA // , // [2 x 2] // x y // -- -- // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // ) You extract some number of rows or columns:\nf.head(2) // operates on rows // res39: Frame[String, String, Int] = [2 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // // operates on rows  f.tail(2) // res40: Frame[String, String, Int] = [2 x 2] // x y // -- -- // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 //  f.headCol(1) // operates on cols // res41: Frame[String, String, Int] = [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // // operates on cols  f.tailCol(1) // res42: Frame[String, String, Int] = [3 x 1] // y // -- // a -\u0026gt; NA // b -\u0026gt; 3 // c -\u0026gt; 4 // Or the first \u0026amp; last of some key (which is helpful when you’ve got a multi-key index):\nf.first(\u0026#34;b\u0026#34;) // first row indexed by \u0026#34;b\u0026#34; key // res43: Series[String, Int] = [2 x 1] // x -\u0026gt; 2 // y -\u0026gt; 3 // // first row indexed by \u0026#34;b\u0026#34; key  f.last(\u0026#34;b\u0026#34;) // last row indexed by \u0026#34;b\u0026#34; key // res44: Series[String, Int] = [2 x 1] // x -\u0026gt; 2 // y -\u0026gt; 3 // // last row indexed by \u0026#34;b\u0026#34; key  f.firstCol(\u0026#34;x\u0026#34;) // res45: Series[String, Int] = [3 x 1] // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA //  f.lastCol(\u0026#34;x\u0026#34;) // res46: Series[String, Int] = [3 x 1] // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // There are a few other methods of extracting data:\nimport org.saddle.linalg._ f.filter { case s =\u0026gt; s.toVec.map(_.toDouble).mean2 \u0026gt; 2.0 } // any column whose series satisfies predicate // res47: Frame[String, String, Int] = Empty Frame // any column whose series satisfies predicate  f.filterIx { case x =\u0026gt; x == \u0026#34;x\u0026#34; } // col where index matches key \u0026#34;x\u0026#34; // res48: Frame[String, String, Int] = [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // // col where index matches key \u0026#34;x\u0026#34;  f.where(Vec(false, true)) // extract second column // res49: Frame[String, String, Int] = [3 x 1] // y // -- // a -\u0026gt; NA // b -\u0026gt; 3 // c -\u0026gt; 4 // There are analogous methods to operate on rows rather then columns:\nrfilter rfilterIx rwhere etc\u0026hellip; in general, methods operate on a column-wise basis, whereas the r-counterpart does so on a row-wise basis.\nYou can drop cols (rows) containing any NA values:\nf.dropNA // res50: Frame[String, String, Int] = Empty Frame  f.rdropNA // res51: Frame[String, String, Int] = [1 x 2] // x y // -- -- // b -\u0026gt; 2 3 // Let’s take a look at some operations we can do with Frames. We can do all the normal binary math operations with Frames, with either a scalar value or with another Frame. When two frames are involved, they are reindexed along both axes to match the outer join of their indices, but any missing observation in either will carry through the calculations.\nf + 1 // res52: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 2 NA // b -\u0026gt; 3 4 // c -\u0026gt; NA 5 //  f * f // res53: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 4 9 // c -\u0026gt; NA 16 //  val g = Frame(\u0026#34;y\u0026#34;-\u0026gt;Series(\u0026#34;b\u0026#34;-\u0026gt;5, \u0026#34;d\u0026#34;-\u0026gt;10)) // g: Frame[String, String, Int] = [2 x 1] // y // -- // b -\u0026gt; 5 // d -\u0026gt; 10 //  f + g // one non-NA entry, (\u0026#34;b\u0026#34;, \u0026#34;y\u0026#34;, 8) // res54: Frame[String, String, Int] = [4 x 2] // x y // -- -- // a -\u0026gt; NA NA // b -\u0026gt; NA 8 // c -\u0026gt; NA NA // d -\u0026gt; NA NA // You can effectively supply your own binary frame operation using joinMap, which lets you control the join style on rows and columns:\nf.joinMap(g, rhow=index.LeftJoin, chow=index.LeftJoin) { case (x, y) =\u0026gt; x + y } // res55: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; NA NA // b -\u0026gt; NA 8 // c -\u0026gt; NA NA // If you want simply to align one frame to another without performing an operation, use the following method:\nval (fNew, gNew) = f.align(g, rhow=index.LeftJoin, chow=index.OuterJoin) // fNew: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // gNew: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; NA NA // b -\u0026gt; NA 5 // c -\u0026gt; NA NA // If you want to treat a Frame as a matrix to use in linear algebraic fashion, call the toMat method.\nWe can sort a frame in various ways:\nf.sortedRIx // sorted by row index // res56: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // sorted by row index  f.sortedCIx // sorted by col index // res57: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // sorted by col index  f.sortedRows(0,1) // sort rows by (primary) col 0 and (secondary) col 1 // res58: Frame[String, String, Int] = [3 x 2] // x y // -- -- // c -\u0026gt; NA 4 // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // // sort rows by (primary) col 0 and (secondary) col 1  f.sortedCols(1,0) // sort cols by (primary) row 1 and (secondary) row 0 // res59: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // We can also sort by an ordering provided by the result of a function acting on rows or cols:\nf.sortedRowsBy { case r =\u0026gt; r.at(0) } // sort rows by first element of row // res60: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // sort rows by first element of row  f.sortedColsBy { case c =\u0026gt; c.at(0) } // sort cols by first element of col // res61: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // There are several mapping functions:\nf.mapValues { case t =\u0026gt; t + 1 } // add one to each element of frame // res62: Frame[String, String, Int] = [3 x 2] // x y // -- -- // a -\u0026gt; 2 NA // b -\u0026gt; 3 4 // c -\u0026gt; NA 5 // // add one to each element of frame  import org.saddle.linalg._ f.mapVec { case v =\u0026gt; v.map(_.toDouble).demeaned } // map over each col vec of the frame // res63: Frame[String, String, Double] = [3 x 2] // x y // -- -- // a -\u0026gt; NA NA // b -\u0026gt; NA NA // c -\u0026gt; NA NA // // map over each col vec of the frame  f.reduce { case s =\u0026gt; s.toVec.map(_.toDouble).mean2 } // collapse each col series to a single value // res64: Series[String, Double] = [2 x 1] // x -\u0026gt; NA // y -\u0026gt; NA // // collapse each col series to a single value  f.transform { case s =\u0026gt; s.reversed } // transform each series; outerjoin results // res65: Frame[String, String, Int] = [3 x 2] // x y // -- -- // c -\u0026gt; NA 4 // b -\u0026gt; 2 3 // a -\u0026gt; 1 NA // We can mask out values:\nf.mask(_ \u0026gt; 2) // mask out values \u0026gt; 2 f.mask(Vec(false, true, true)) // mask out rows 1 \u0026amp; 2 (keep row 0) Columns (rows) containing only NA values can be dropped as follows:\nf.mask(Vec(true, false, false)).rsqueeze // drop rows containing NA values // res66: Frame[String, String, Int] = [2 x 2] // x y // -- -- // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // // drop rows containing NA values  f.rmask(Vec(false, true)).squeeze // takes \u0026#34;x\u0026#34; column // res67: Frame[String, String, Int] = [3 x 1] // x // -- // a -\u0026gt; 1 // b -\u0026gt; 2 // c -\u0026gt; NA // We can groupBy in order to combine or transform:\nimport org.saddle.linalg._ f.groupBy(_ == \u0026#34;a\u0026#34;).combine(_.count) // # obs in each column that have/not row key \u0026#34;a\u0026#34; // res68: Frame[Boolean, String, Int] = [2 x 2] // x y // -- -- // false -\u0026gt; 1 2 // true -\u0026gt; 1 0 // // # obs in each column that have/not row key \u0026#34;a\u0026#34;  f.groupBy(_ == \u0026#34;a\u0026#34;).transform(_.map(_.toDouble).demeaned) // contrived, but you get the idea hopefully! // res69: Frame[String, String, Double] = [3 x 2] // x y // ------ ------- // a -\u0026gt; 0.0000 NA // b -\u0026gt; NA -0.5000 // c -\u0026gt; NA 0.5000 // We can join against another frame, or against a series.\nf.rconcat(g, how=index.LeftJoin) // res70: Frame[String, String, Int] = [3 x 3] // x y y // -- -- -- // a -\u0026gt; 1 NA NA // b -\u0026gt; 2 3 5 // c -\u0026gt; NA 4 NA //  f.concat(g, how=index.LeftJoin) // res71: Frame[String, String, Int] = [5 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // b -\u0026gt; NA 5 // d -\u0026gt; NA 10 //  f.cbind(g, how=index.LeftJoin) // res72: Frame[String, String, Int] = [3 x 3] // x y y // -- -- -- // a -\u0026gt; 1 NA NA // b -\u0026gt; 2 3 5 // c -\u0026gt; NA 4 NA //  f.rbind(g, how=index.LeftJoin) // res73: Frame[String, String, Int] = [5 x 2] // x y // -- -- // a -\u0026gt; 1 NA // b -\u0026gt; 2 3 // c -\u0026gt; NA 4 // b -\u0026gt; NA 5 // d -\u0026gt; NA 10 // Btw, to join a Frame to a series, the call looks like this:\ns.joinF(g, how=index.LeftJoin) // res74: Frame[String, Int, Int] = [3 x 2] // 0 1 // -- -- // b -\u0026gt; 3 5 // b -\u0026gt; 4 5 // d -\u0026gt; NA 10 // "},{"id":12,"href":"/saddle/docs/linalg/","title":"Linear algebra","section":"Docs","content":"Saddle exposes the most often used linear algebra operations through a binding to BLAS and LAPACK, thereby linear algebra on saddle is fast and hardware efficient. Data is not copied to an off heap memory segment for this to work.\nThese operations are available only for Vec[Double] and Mat[Double] instances. Linear algebra needs the saddle-linalg dependency.\nThe linear algebra API is exposed as a set of extension methods. See the scaladoc for the list of supported operations.\n"},{"id":13,"href":"/saddle/docs/datastructures/6_buffer/","title":"Mutable buffer","section":"Data structures","content":"Buffer is a mutable data structure with two operations:\n append an element convert the buffer to an array or arrays.   Internally it is stored as a growable sequence of arrays. It never recopies data internally during an append, but it may allocate during append. It is specialized for primitive types. It can store more elements than Int.MaxValue, however in this case toArray will throw (use toArrays).  val b = org.saddle.Buffer.empty[Int] // b: org.saddle.Buffer[Int] = org.saddle.Buffer@5e4d75cd  b += 3 // res0: org.saddle.Buffer[Int] = org.saddle.Buffer@5e4d75cd  b.toArray // res1: Array[Int] = Array(3) "}]